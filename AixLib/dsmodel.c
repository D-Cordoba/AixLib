#define DYNEventSpecial
/* DSblock model generated by Dymola from Modelica model AixLib.Fluid.HeatPumps.Examples.Carnot_RE1
 Dymola Version 2019 (64-bit), 2018-04-11 translated this at Mon Sep 16 18:28:35 2019

   */

#include <matrixop.h>
static const char* DymArrays5[1]={"SimpleLiquidWater"};
#if defined(DynSimStruct) || defined(BUILDFMU)
static double DymArrays1[3]={2.380952380952381, 6000.0, 1.0};
static double DymArrays2[4]={4.0, 4.0, 4.0, 4.0};
static double DymArrays0[4]={10.0, 100000.0, 2.380952380952381, 1.0};
static double DymArrays3[4]={995.586, 300000.0, 293.15, 995.586};
static double DymArrays4[11]={2.0000000000000002E-07, 5000000.0, -75000000.0, 
  2.975E+15, -4.5125E+22, 3.3375E+29, -1.1875E+36, 1.625E+42, 300000.0, 293.15, 
  4184.0};
#endif
/* Declaration of C-structs */
/* Prototypes for functions used in model */
DYMOLA_STATIC double   AixLib_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow
  (double  mx_0flow, double  k0_0, double  mx_0flowx_0turbulent);
DYMOLA_STATIC double   AixLib_Utilities_Math_Functions_BaseClasses_derx_0smoothTransition
  (double  x0_0, double  delta0_0, double  deltaInv0_0, double  a0_0, double  
  b0_0, double  c0_0, double  d0_0, double  e0_0, double  f0_0, double  xx_0der);
DYMOLA_STATIC double   AixLib_Utilities_Math_Functions_BaseClasses_smoothTransition
  (double  x0_0, double  delta0_0, double  deltaInv0_0, double  a0_0, double  
  b0_0, double  c0_0, double  d0_0, double  e0_0, double  f0_0);
DYMOLA_STATIC double   AixLib_Utilities_Math_Functions_polynomial(double  x0_0, 
  RealArray   a0_0);
DYMOLA_STATIC double   AixLib_Utilities_Math_Functions_regStep(double  x0_0, 
  double  y10_0, double  y20_0, double  xx_0small);
DYMOLA_STATIC double   AixLib_Utilities_Math_Functions_smoothLimit(double  x0_0,
   double  l0_0, double  u0_0, double  deltaX0_0);
DYMOLA_STATIC double   AixLib_Utilities_Math_Functions_smoothMax(double  x10_0, 
  double  x20_0, double  deltaX0_0);
DYMOLA_STATIC double   AixLib_Utilities_Math_Functions_smoothMin(double  x10_0, 
  double  x20_0, double  deltaX0_0);
DYMOLA_STATIC void Modelica_Fluid_Utilities_checkBoundary(const char*  
  mediumName0_0, StringArray   substanceNames0_0, int  singleState0_0, int  
  definex_0p, RealArray   Xx_0boundary, const char*  modelName0_0);
/* Codes used in model */

/* Flattened Modelica model:

function AixLib.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow
discrete input Real m_flow(unit = "kg/s") "Mass flow rate in design flow direction";
discrete input Real k "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)";
discrete input Real m_flow_turbulent(unit = "kg/s", min = 0.0) "Mass flow rate where transition to turbulent flow occurs";
discrete output Real dp(unit = "Pa", displayUnit = "Pa") "Pressure difference between port_a and port_b (= port_a.p - port_b.p)";
protected 
discrete Real dp_turbulent(start = (m_flow_turbulent/k)^2, unit = "Pa", displayUnit = "bar") "Pressure where flow changes to turbulent";
discrete Real m_flowNorm(start = m_flow/m_flow_turbulent) "Normalised mass flow rate";
discrete Real m_flowNormSq(start = m_flowNorm^2) "Square of normalised mass flow rate";
public 
algorithm 
dp := (if noEvent(abs(m_flow) > m_flow_turbulent) then noEvent((if m_flow > 0 then 1 else (if m_flow < 0 then -1 else 0)))*(m_flow/k)^2 else (0.375+(0.75-0.125*m_flowNormSq)*m_flowNormSq)*dp_turbulent*m_flowNorm);
annotation(derivative(zeroDerivative=k, zeroDerivative=m_flow_turbulent)=AixLib.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow_der, LateInline=true, smoothOrder=2);
end AixLib.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow;

  */
DYMOLA_STATIC double   AixLib_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow
  (double  mx_0flow, double  k0_0, double  mx_0flowx_0turbulent) {
  PushContext("AixLib.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow")
  {
    /* Declare outputs and temporaries */
    double   dp0_0;
    double   dpx_0turbulent;
    double   mx_0flowNorm;
    double   mx_0flowNormSq;
    dp0_0=0;
    dpx_0turbulent = sqr(divmacro(mx_0flowx_0turbulent,"m_flow_turbulent",k0_0,
      "k"));
    mx_0flowNorm = divmacro(mx_0flow,"m_flow",mx_0flowx_0turbulent,
      "m_flow_turbulent");
    mx_0flowNormSq = sqr(mx_0flowNorm);
    /* Start of real code */
      dp0_0 = IF fabs(mx_0flow) > mx_0flowx_0turbulent THEN (IF mx_0flow > 0
         THEN 1 ELSE IF mx_0flow < 0 THEN -1 ELSE 0)*sqr(divmacro(mx_0flow,
        "m_flow",k0_0,"k")) ELSE (0.375+(0.75-0.125*mx_0flowNormSq)*
        mx_0flowNormSq)*dpx_0turbulent*mx_0flowNorm;
    /* Output section */
    PopContext()
    return dp0_0;
  }}

/* Flattened Modelica model:

function AixLib.Utilities.Math.Functions.BaseClasses.der_smoothTransition
discrete input Real x "Abscissa value";
discrete input Real delta(min = 1E-15) "Abscissa value below which approximation occurs";
discrete input Real deltaInv "Inverse value of delta";
discrete input Real a "Polynomial coefficient";
discrete input Real b "Polynomial coefficient";
discrete input Real c "Polynomial coefficient";
discrete input Real d "Polynomial coefficient";
discrete input Real e "Polynomial coefficient";
discrete input Real f "Polynomial coefficient";
discrete input Real x_der "Derivative of x";
discrete output Real y_der "Derivative of function value";
protected 
discrete Real aX "Absolute value of x";
public 
algorithm 
aX := abs(x);
y_der := (b+aX*(2*c+aX*(3*d+aX*(4*e+aX*5*f))))*x_der;
annotation(derivative(order=2, zeroDerivative=a, zeroDerivative=b, zeroDerivative=c, zeroDerivative=d, zeroDerivative=delta, zeroDerivative=deltaInv, zeroDerivative=e, zeroDerivative=f)=AixLib.Utilities.Math.Functions.BaseClasses.der_2_smoothTransition, smoothOrder=1);
end AixLib.Utilities.Math.Functions.BaseClasses.der_smoothTransition;

  */
DYMOLA_STATIC double   AixLib_Utilities_Math_Functions_BaseClasses_derx_0smoothTransition
  (double  x0_0, double  delta0_0, double  deltaInv0_0, double  a0_0, double  
  b0_0, double  c0_0, double  d0_0, double  e0_0, double  f0_0, double  xx_0der)
   {
  PushContext("AixLib.Utilities.Math.Functions.BaseClasses.der_smoothTransition")
  {
    /* Declare outputs and temporaries */
    double   yx_0der;
    double   aX0_0;
    yx_0der=0;
    aX0_0=0;
    /* Start of real code */
      aX0_0 = fabs(x0_0);
      yx_0der = (b0_0+aX0_0*(2*c0_0+aX0_0*(3*d0_0+aX0_0*(4*e0_0+aX0_0*5*f0_0))))
        *xx_0der;
    /* Output section */
    PopContext()
    return yx_0der;
  }}

/* Flattened Modelica model:

function AixLib.Utilities.Math.Functions.BaseClasses.smoothTransition
discrete input Real x "Abscissa value";
discrete input Real delta(min = 1E-15) "Abscissa value below which approximation occurs";
discrete input Real deltaInv(start = 1/delta) "Inverse value of delta";
discrete input Real a(start = (-15)*deltaInv) "Polynomial coefficient";
discrete input Real b(start = 119*deltaInv^2) "Polynomial coefficient";
discrete input Real c(start = (-361)*deltaInv^3) "Polynomial coefficient";
discrete input Real d(start = 534*deltaInv^4) "Polynomial coefficient";
discrete input Real e(start = (-380)*deltaInv^5) "Polynomial coefficient";
discrete input Real f(start = 104*deltaInv^6) "Polynomial coefficient";
discrete output Real y "Function value";
protected 
discrete Real aX "Absolute value of x";
public 
algorithm 
aX := abs(x);
y := (if x >= 0 then 1 else -1)*(a+aX*(b+aX*(c+aX*(d+aX*(e+aX*f)))));
annotation(derivative(zeroDerivative=a, zeroDerivative=b, zeroDerivative=c, zeroDerivative=d, zeroDerivative=delta, zeroDerivative=deltaInv, zeroDerivative=e, zeroDerivative=f)=AixLib.Utilities.Math.Functions.BaseClasses.der_smoothTransition, smoothOrder=2);
end AixLib.Utilities.Math.Functions.BaseClasses.smoothTransition;

  */
DYMOLA_STATIC double   AixLib_Utilities_Math_Functions_BaseClasses_smoothTransition
  (double  x0_0, double  delta0_0, double  deltaInv0_0, double  a0_0, double  
  b0_0, double  c0_0, double  d0_0, double  e0_0, double  f0_0) {
  PushContext("AixLib.Utilities.Math.Functions.BaseClasses.smoothTransition")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    double   aX0_0;
    y0_0=0;
    aX0_0=0;
    /* Start of real code */
      aX0_0 = fabs(x0_0);
      y0_0 = (IF x0_0 >= 0 THEN 1 ELSE -1)*(a0_0+aX0_0*(b0_0+aX0_0*(c0_0+aX0_0*(
        d0_0+aX0_0*(e0_0+aX0_0*f0_0)))));
    /* Output section */
    PopContext()
    return y0_0;
  }}

/* Flattened Modelica model:

function AixLib.Utilities.Math.Functions.polynomial
discrete input Real x "Independent variable";
discrete input Real a[:] "Coefficients";
discrete output Real y "Result";
protected 
parameter Integer n = size(a, 1)-1;
discrete Real xp[n+1] "Powers of x";
public 
algorithm 
xp[1] := 1;
for i in (1:n) loop
xp[i+1] := xp[i]*x;
end for;
y := a*xp;
annotation(smoothOrder=999);
end AixLib.Utilities.Math.Functions.polynomial;

  */
DYMOLA_STATIC double   AixLib_Utilities_Math_Functions_polynomial(double  x0_0, 
  RealArray   a0_0) {
  PushContext("AixLib.Utilities.Math.Functions.polynomial")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    int   n0_0;
    RealArray    xp0_0;
    MarkObject retmark_ = PushMark();
    y0_0=0;
    n0_0 = DYNSizeSimple(a0_0, 1)-1;
    xp0_0=RealTemporary( 1, n0_0+1);
    PushMark();
    RealFillAssign( xp0_0, 0);
    /* Start of real code */
      SetRealElement(1, xp0_0, (SizeType)(1));
      {
        int end_ = n0_0;
        int i0_0_0;
        for(i0_0_0 = 1;i0_0_0 <= end_;i0_0_0 += 1) {
          SetRealElement(RealElement( xp0_0, (SizeType)(i0_0_0))*x0_0, xp0_0, 
            (SizeType)(i0_0_0+1));
        }
      }
      y0_0 = RealMultiplyVV (a0_0,xp0_0);
      Release();
    /* Output section */
    PopMark(retmark_);
    PopContext()
    return y0_0;
  }}

/* Flattened Modelica model:

function AixLib.Utilities.Math.Functions.smoothLimit
discrete input Real x "Variable";
discrete input Real l "Low limit";
discrete input Real u "Upper limit";
discrete input Real deltaX "Width of transition interval";
discrete output Real y "Result";
protected 
discrete Real cor;
public 
algorithm 
cor := deltaX/10;
y := AixLib.Utilities.Math.Functions.smoothMax(x, l+deltaX, cor);
y := AixLib.Utilities.Math.Functions.smoothMin(y, u-deltaX, cor);
annotation(smoothOrder=1);
end AixLib.Utilities.Math.Functions.smoothLimit;

  */
DYMOLA_STATIC double   AixLib_Utilities_Math_Functions_smoothLimit(double  x0_0,
   double  l0_0, double  u0_0, double  deltaX0_0) {
  PushContext("AixLib.Utilities.Math.Functions.smoothLimit")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    double   cor0_0;
    y0_0=0;
    cor0_0=0;
    /* Start of real code */
      cor0_0 = deltaX0_0/(double)(10);
      y0_0 = AixLib_Utilities_Math_Functions_smoothMax(x0_0, l0_0+deltaX0_0, 
        cor0_0);
      y0_0 = AixLib_Utilities_Math_Functions_smoothMin(y0_0, u0_0-deltaX0_0, 
        cor0_0);
    /* Output section */
    PopContext()
    return y0_0;
  }}

/* Flattened Modelica model:

function AixLib.Utilities.Math.Functions.smoothMax
discrete input Real x1 "First argument";
discrete input Real x2 "Second argument";
discrete input Real deltaX "Width of transition interval";
discrete output Real y "Result";

algorithm 
y := AixLib.Utilities.Math.Functions.regStep(x1-x2, x1, x2, deltaX);
annotation(Inline=true, smoothOrder=1);
end AixLib.Utilities.Math.Functions.smoothMax;

  */
DYMOLA_STATIC double   AixLib_Utilities_Math_Functions_smoothMax(double  x10_0, 
  double  x20_0, double  deltaX0_0) {
  PushContext("AixLib.Utilities.Math.Functions.smoothMax")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    y0_0=0;
    /* Start of real code */
      y0_0 = AixLib_Utilities_Math_Functions_regStep(x10_0-x20_0, x10_0, x20_0, 
        deltaX0_0);
    /* Output section */
    PopContext()
    return y0_0;
  }}

/* Flattened Modelica model:

function AixLib.Utilities.Math.Functions.smoothMin
discrete input Real x1 "First argument";
discrete input Real x2 "Second argument";
discrete input Real deltaX "Width of transition interval";
discrete output Real y "Result";

algorithm 
y := AixLib.Utilities.Math.Functions.regStep(x2-x1, x1, x2, deltaX);
annotation(Inline=true, smoothOrder=1);
end AixLib.Utilities.Math.Functions.smoothMin;

  */
DYMOLA_STATIC double   AixLib_Utilities_Math_Functions_smoothMin(double  x10_0, 
  double  x20_0, double  deltaX0_0) {
  PushContext("AixLib.Utilities.Math.Functions.smoothMin")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    y0_0=0;
    /* Start of real code */
      y0_0 = AixLib_Utilities_Math_Functions_regStep(x20_0-x10_0, x10_0, x20_0, 
        deltaX0_0);
    /* Output section */
    PopContext()
    return y0_0;
  }}

/* Flattened Modelica model:

function Modelica.Fluid.Utilities.checkBoundary
input String mediumName;
input String substanceNames[:] "Names of substances";
input Boolean singleState;
input Boolean define_p;
discrete input Real X_boundary[:];
input String modelName(start = "??? boundary ???");
protected 
Integer nX(start = size(X_boundary, 1));
String X_str;
public 
algorithm 
assert( not singleState or singleState and define_p, "
Wrong value of parameter define_p (= false) in model \""+modelName+"\":
The selected medium \""+mediumName+"\" has Medium.singleState=true.
Therefore, an boundary density cannot be defined and
define_p = true is required.
");
for i in (1:nX) loop
assert(X_boundary[i] >= 0.0, "
Wrong boundary mass fractions in medium \""+mediumName+"\" in model \""+modelName+"\":
The boundary value X_boundary("+       String(i, true, 0)+") = "+       String(X_boundary[i], true, 0)+"
is negative. It must be positive.
");
end for;
if (nX > 0 and abs(sum(X_boundary)-1.0) > 1E-10) then 
X_str := "";
for i in (1:nX) loop
X_str := X_str+"   X_boundary["+       String(i, true, 0)+"] = "+       String(X_boundary[i], true, 0)+" \""+substanceNames[i]+"\"\n";
end for;
ModelicaError("The boundary mass fractions in medium \""+mediumName+"\" in model \""+modelName+"\"\n"+"do not sum up to 1. Instead, sum(X_boundary) = "+       String(sum(X_boundary), true, 0)+":\n"+X_str);
end if;
end Modelica.Fluid.Utilities.checkBoundary;

  */
DYMOLA_STATIC void Modelica_Fluid_Utilities_checkBoundary(const char*  
  mediumName0_0, StringArray   substanceNames0_0, int  singleState0_0, int  
  definex_0p, RealArray   Xx_0boundary, const char*  modelName0_0) {
  char*retSMark_=GetStringMark();
  PushContext("Modelica.Fluid.Utilities.checkBoundary")
  {
    /* Declare outputs and temporaries */
    int   nX0_0;
    const char*   Xx_0str;
    MarkObject retmark_ = PushMark();
    nX0_0 = DYNSizeSimple(Xx_0boundary, 1);
    Xx_0str="";
    /* Start of real code */
      AssertModelica( NOT singleState0_0 OR singleState0_0 AND definex_0p,
        " not singleState or singleState and define_p", StringAdd(StringAdd(
        StringAdd(StringAdd("\nWrong value of parameter define_p (= false) in model \"",
        modelName0_0),"\":\nThe selected medium \""),mediumName0_0),
        "\" has Medium.singleState=true.\nTherefore, an boundary density cannot be defined and\ndefine_p = true is required.\n"));
      {
        int end_ = nX0_0;
        int i0_0_0;
        for(i0_0_0 = 1;i0_0_0 <= end_;i0_0_0 += 1) {
          AssertModelica(RealElement( Xx_0boundary, (SizeType)(i0_0_0)) >= 0.0,
            "X_boundary[i] >= 0.0", StringAdd(StringAdd(StringAdd(StringAdd(
            StringAdd(StringAdd(StringAdd(StringAdd("\nWrong boundary mass fractions in medium \"",
            mediumName0_0),"\" in model \""),modelName0_0),"\":\nThe boundary value X_boundary("),
            Integer2String2(i0_0_0, true, 0)),") = "),Real2String2(RealElement( 
            Xx_0boundary, (SizeType)(i0_0_0)), true, 0)),"\nis negative. It must be positive.\n"));
        }
      }
      if (nX0_0 > 0 AND fabs(Realsum( Xx_0boundary)-1.0) > 1E-10) {
        Xx_0str = SqueezeString("", retSMark_);
        Release();
        {
          int end_ = nX0_0;
          int i0_0_0;
          for(i0_0_0 = 1;i0_0_0 <= end_;i0_0_0 += 1) {
            Xx_0str = SqueezeString(StringAdd(StringAdd(StringAdd(StringAdd(
              StringAdd(StringAdd(StringAdd(Xx_0str,"   X_boundary["),
              Integer2String2(i0_0_0, true, 0)),"] = "),Real2String2(
              RealElement( Xx_0boundary, (SizeType)(i0_0_0)), true, 0))," \""),
              StringElement( substanceNames0_0, (SizeType)(i0_0_0))),"\"\n"), retSMark_);
          }
        }
        ModelicaError(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(
          StringAdd(StringAdd(StringAdd("The boundary mass fractions in medium \"",
          mediumName0_0),"\" in model \""),modelName0_0),"\"\n"),
          "do not sum up to 1. Instead, sum(X_boundary) = "),Real2String2(
          Realsum( Xx_0boundary), true, 0)),":\n"),Xx_0str));
        Release();
      }
    /* Output section */
    PopMark(retmark_);
    SetStringMark(retSMark_);
    PopContext()
    return ;
  }}

/* Flattened Modelica model:

function AixLib.Utilities.Math.Functions.regStep
discrete input Real x "Abscissa value";
discrete input Real y1 "Ordinate value for x > 0";
discrete input Real y2 "Ordinate value for x < 0";
discrete input Real x_small(start = 1E-05, min = 0.0) "Approximation of step for -x_small <= x <= x_small; x_small >= 0 required";
discrete output Real y "Ordinate value to approximate y = if x > 0 then y1 else y2";

algorithm 
y := smooth(1, (if x > x_small then y1 else (if x <  -x_small then y2 else (if x_small > 0 then x/x_small*((x/x_small)^2-3)*(y2-y1)/4+(y1+y2)/2 else (y1+y2)/2))));
annotation(Inline=true);
end AixLib.Utilities.Math.Functions.regStep;

  */
DYMOLA_STATIC double   AixLib_Utilities_Math_Functions_regStep(double  x0_0, 
  double  y10_0, double  y20_0, double  xx_0small) {
  PushContext("AixLib.Utilities.Math.Functions.regStep")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    y0_0=0;
    /* Start of real code */
      y0_0 = IF x0_0 > xx_0small THEN y10_0 ELSE IF x0_0 <  -xx_0small THEN 
        y20_0 ELSE IF xx_0small > 0 THEN divmacro(x0_0,"x",xx_0small,"x_small")*
        (sqr(divmacro(x0_0,"x",xx_0small,"x_small"))-3)*(y20_0-y10_0)/(double)(4)
        +(y10_0+y20_0)/(double)(2) ELSE (y10_0+y20_0)/(double)(2);
    /* Output section */
    PopContext()
    return y0_0;
  }}
/* DSblock C-code: */

BreakSectionFunctionDef(1)
BreakSectionFunctionDef(0)
#define NX_    0
#define NX2_   0
#define NU_    0
#define NY_    0
#define NW_    321
#define NP_    43
#define NPS_   0
#define ND_   0
#define NXP_   0
#define NInitial_   2
#define MAXAuxStr_   1
#define MAXAuxStrLen_   500
#define NHash1_ -852525855
#define NHash2_ -1198388777
#define NHash3_ 0
#define NI_    0
#define NRelF_ 3
#define NRel_  3
#define NTim_  2
#define NSamp_ 0
#define NCons_ 0
#define NA_    112
#define SizePre_ 0
#define SizeEq_ 3
#define SizeDelay_ 0
#define QNLmax_ 2
#define MAXAux 10
#define NrDymolaTimers_ 0
#define NWhen_ 0
#define NCheckIf_ 0
#define NGlobalHelp_ 172
#define NGlobalHelpI_ 48
#ifndef NExternalObject_
#define NExternalObject_ 0
#endif
#include <moutil.c>
DYMOLA_STATIC unsigned int FMIClockValueReferences_[1]={0};
DYMOLA_STATIC unsigned int FMIClockFirstValueReferences_[1]={0};
PreNonAliasDef(0)
PreNonAliasDef(1)
PreNonAliasDef(2)
PreNonAliasDef(3)
PreNonAliasDef(4)
PreNonAliasDef(5)
#if !defined(DYM2CCUR)
 DYMOLA_STATIC const char*modelName="AixLib.Fluid.HeatPumps.Examples.Carnot_RE1";
#endif
DYMOLA_STATIC const char*usedLibraries[]={0};
DYMOLA_STATIC const char*dllLibraryPath[]={0};
DYMOLA_STATIC const char*default_dymosim_license_filename=
 "c:/programdata/dassaultsystemes/dymola/dymola.lic";
#include <dsblock1.c>

/* Define variable names. */

#define Sections_

TranslatedEquations

InitialSection
#if defined(DynSimStruct) || defined(BUILDFMU)
memcpy(&DYNX(W_,0), &DymArrays0, sizeof(double)*4);
DYNX(W_,4) = false;
DYNX(W_,8) = 3;
DYNX(W_,10) = false;
DYNX(W_,13) = false;
DYNX(W_,14) = false;
DYNX(W_,15) = false;
DYNX(W_,16) = false;
DYNX(W_,17) = 1;
DYNX(W_,18) = false;
DYNX(W_,22) = 3;
DYNX(W_,24) = true;
DYNX(W_,25) = false;
DYNX(W_,26) = false;
DYNX(W_,27) = false;
DYNX(W_,28) = false;
DYNX(W_,29) = 1;
DYNX(W_,34) = false;
DYNX(W_,40) = 3;
DYNX(W_,43) = 1;
DYNX(W_,48) = false;
DYNX(W_,53) = 3;
DYNX(W_,62) = false;
DYNX(W_,63) = false;
DYNX(W_,70) = 2.380952380952381;
DYNX(W_,71) = 2;
DYNX(W_,74) = true;
DYNX(W_,93) = 6000;
DYNX(W_,94) = 6000;
DYNX(W_,104) = 4;
DYNX(W_,123) = false;
DYNX(W_,127) = 2.380952380952381;
DYNX(W_,129) = false;
DYNX(W_,136) = 6000;
DYNX(W_,141) = false;
DYNX(W_,145) = 2.380952380952381;
DYNX(W_,147) = false;
DYNX(W_,153) = 6000;
memcpy(&DYNX(W_,158), &DymArrays1, sizeof(double)*3);
DYNX(W_,165) = false;
DYNX(W_,171) = false;
DYNX(W_,185) = true;
DYNX(W_,186) = false;
DYNX(W_,211) = true;
DYNX(W_,212) = false;
DYNX(W_,215) = false;
DYNX(W_,217) = 2;
DYNX(W_,219) = false;
DYNX(W_,225) = 6000;
DYNX(W_,230) = 4;
DYNX(W_,231) = 4;
memcpy(&DYNX(W_,233), &DymArrays2, sizeof(double)*4);
DYNX(W_,242) = true;
DYNX(W_,243) = true;
DYNX(W_,245) = 2;
DYNX(W_,247) = false;
DYNX(W_,259) = true;
DYNX(W_,260) = false;
DYNX(W_,261) = false;
DYNX(W_,263) = 2;
DYNX(W_,265) = false;
DYNX(W_,270) = 6000;
DYNX(W_,275) = 2;
DYNX(W_,276) = 6000;
DYNX(W_,294) = false;
DYNX(W_,298) = false;
DYNX(W_,302) = true;
DYNX(W_,303) = true;
DYNX(W_,304) = false;
DYNX(W_,305) = false;
#endif
DYNSetAuxString(did_, "SimpleLiquidWater", 0);
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,319) = 200;
DYNX(W_,92) = 1.0;
DYNX(W_,97) = true;
DYNX(W_,98) = false;
DYNX(W_,99) = false;
DYNX(W_,100) = false;
DYNX(W_,101) = false;
DYNX(W_,102) = 0.1;
DYNX(W_,103) = 0.1;
DYNX(W_,289) = -60000;
DYNX(W_,290) = 30000;
DYNX(W_,11) = 2.380952380952381;
DYNX(W_,35) = true;
DYNX(W_,41) = true;
DYNX(W_,42) = true;
DYNX(W_,49) = true;
DYNX(W_,54) = true;
DYNX(W_,55) = true;
DYNX(W_,61) = 4184;
DYNX(W_,72) = 0.0002380952380952381;
DYNX(W_,73) = 0.0002;
DYNX(W_,89) = 10;
DYNX(W_,117) = 4184;
DYNX(W_,95) = 2;
DYNX(W_,118) = 4184;
DYNX(W_,96) = 2;
DYNX(W_,114) = true;
DYNX(W_,128) = 0.0001;
DYNX(W_,132) = 0;
DYNX(W_,133) = 0;
DYNX(W_,134) = true;
DYNX(W_,135) = false;
DYNX(W_,137) = false;
DYNX(W_,138) = 0.1;
DYNX(W_,140) = false;
DYNX(W_,146) = 0.0002380952380952381;
DYNX(W_,150) = 0;
DYNX(W_,151) = 0;
DYNX(W_,152) = false;
DYNX(W_,154) = false;
DYNX(W_,155) = false;
DYNX(W_,163) = true;
DYNX(W_,161) = 0.1;
DYNX(W_,156) = 0.2380952380952381;
DYNX(W_,157) = 0.001;
DYNX(W_,162) = 0.030737963065138228;
DYNX(W_,164) = 0;
DYNX(W_,169) = 2.380952380952381;
DYNX(W_,170) = 0.0001;
DYNX(W_,174) = 0;
DYNX(W_,175) = 0;
DYNX(W_,203) = 30000.0;
DYNX(W_,176) = 30000.0;
DYNX(W_,204) = -60000.0;
DYNX(W_,177) = -60000.0;
DYNX(W_,205) = 0;
DYNX(W_,178) = 0.0;
DYNX(W_,206) = 0;
DYNX(W_,179) = 0.0;
DYNX(W_,208) = 1;
DYNX(W_,182) = 1.0;
DYNX(W_,209) = 4;
DYNX(W_,183) = 4;
DYNX(W_,210) = 4;
DYNX(W_,184) = 4;
DYNX(W_,188) = true;
DYNX(W_,189) = true;
DYNX(W_,190) = true;
DYNX(W_,191) = true;
DYNX(W_,218) = 0.0001;
DYNX(W_,221) = 0;
DYNX(W_,222) = 0;
DYNX(W_,223) = true;
DYNX(W_,224) = false;
DYNX(W_,226) = false;
DYNX(W_,227) = 0.1;
DYNX(W_,229) = true;
DYNX(W_,240) = 1;
DYNX(W_,241) = false;
DYNX(W_,244) = 2;
DYNX(W_,246) = 0.0002;
DYNX(W_,281) = 995.586;
memcpy(&DYNX(W_,253), &DymArrays3, sizeof(double)*4);
DYNX(W_,264) = 0.0002;
DYNX(W_,267) = 0;
DYNX(W_,268) = 0;
DYNX(W_,269) = false;
DYNX(W_,271) = true;
DYNX(W_,272) = false;
DYNX(W_,279) = true;
DYNX(W_,277) = 0.1;
DYNX(W_,273) = 0.2;
DYNX(W_,274) = 0.001;
DYNX(W_,278) = 0.025819888974716113;
DYNX(W_,280) = 0;
DYNX(W_,285) = 1;
DYNX(W_,287) = 0;
DYNX(W_,288) = 1.0;
DYNX(W_,291) = 100000.0;
DYNX(W_,293) = -1;
DYNX(W_,296) = 2.0;
DYNX(W_,297) = 0.0002;
DYNX(W_,300) = 0;
DYNX(W_,301) = 0;
DYNX(W_,306) = true;
memcpy(&DYNX(W_,308), &DymArrays4, sizeof(double)*11);
DYNX(W_,173) = 0;
DYNX(W_,193) = 2.380952380952381;
DYNX(W_,194) = 2.380952380952381;
DYNX(W_,107) = 1;
DYNX(W_,31) = 1;
DYNX(W_,32) = 0;
DYNX(W_,45) = 1;
DYNX(W_,46) = 0;
DYNX(W_,199) = 0;
DYNX(W_,201) = 1.0;
DYNX(W_,200) = 1.0;
DYNX(W_,214) = 0;
DYNX(W_,251) = 0;
DYNX(W_,252) = 0;
DYNX(W_,299) = 0.0;
DYNX(W_,320) = 0;
DYNX(W_,9) = 1.0;
DYNX(W_,23) = 1.0;
DYNX(W_,130) = 2.380952380952381;
DYNX(W_,202) = 0.01;
DYNX(W_,196) = 0.01;
DYNX(W_,197) = 0.0;
DYNX(W_,187) = 0.0;
DYNX(W_,172) = 2.380952380952381;
DYNX(W_,167) = 83680.0;
DYNX(W_,166) = 2.380952380952381;
DYNX(W_,168) = -2.380952380952381;
DYNX(W_,125) = 83680.0;
DYNX(W_,124) = 2.380952380952381;
DYNX(W_,126) = -2.380952380952381;
DYNX(W_,148) = 2.380952380952381;
DYNX(W_,143) = 83680.0;
DYNX(W_,142) = 2.380952380952381;
DYNX(W_,144) = -2.380952380952381;
DYNX(W_,90) = 0.3;
DYNX(W_,216) = 83680.0;
DYNX(W_,262) = 83680.0;
DYNX(W_,249) = 83680.0;
DYNX(W_,295) = 83680.0;
DYNX(W_,75) = 2.380952380952381;
DYNX(W_,65) = 83680.0;
DYNX(W_,64) = 2.380952380952381;
DYNX(W_,68) = 83680.0;
DYNX(W_,66) = -2.380952380952381;
DYNX(W_,33) = 0.018015268;
DYNX(W_,30) = 995.586;
DYNX(W_,38) = 2.380952380952381;
DYNX(W_,47) = 0.018015268;
DYNX(W_,44) = 995.586;
DYNX(W_,12) = 2.380952380952381;
DYNX(W_,5) = -2.380952380952381;
#endif
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
BoundParameterSection
AssertModelica(DYNX(DP_,8) >= 272.15 AND DYNX(DP_,8) <= 403.15,"sin1.T >= 272.15 and sin1.T <= 403.15",
   StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(
  StringAdd("\nTemperature T (= ",Real2String2(DYNX(DP_,8), true, 0)),
  " K) is not\nin the allowed range ("),"272.15")," K <= T <= "),"403.15"),
  " K)\nrequired from medium model \""),"SimpleLiquidWater"),"\".\n"));
PopAllMarks();
AssertModelica(DYNX(DP_,13) >= 272.15 AND DYNX(DP_,13) <= 403.15,
  "sin2.T >= 272.15 and sin2.T <= 403.15", StringAdd(StringAdd(StringAdd(
  StringAdd(StringAdd(StringAdd(StringAdd(StringAdd("\nTemperature T (= ",
  Real2String2(DYNX(DP_,13), true, 0))," K) is not\nin the allowed range ("),
  "272.15")," K <= T <= "),"403.15")," K)\nrequired from medium model \""),
  "SimpleLiquidWater"),"\".\n"));
PopAllMarks();
BoundParameterSection
DYNX(W_,57) =  -divmacro(divmacro(1,"1",DYNX(W_,61),"cp2_default"),
  "1/cp2_default",DYNX(DP_,0),"dTEva_nominal");
DYNX(W_,88) = DYNX(DP_,0);
AssertModelica(DYNX(W_,88) < 0,"heaPum.dTEva_nominal < 0", "Parameter dTEva_nominal must be negative.");
DYNX(W_,139) = DYNX(DP_,25);
DYNX(W_,180) = DYNX(W_,139);
DYNX(W_,207) = DYNX(DP_,27);
DYNX(W_,181) = DYNX(W_,207);
DYNX(W_,192) = DYNX(DP_,31)*1E-06;
DYNX(W_,228) = DYNX(DP_,26);
DYNX(W_,232) = DYNX(DP_,28);
DYNX(W_,237) = DYNX(DP_,33);
DYNX(W_,238) = DYNX(W_,232);
DYNX(W_,239) = DYNX(DP_,34);
DYNX(W_,248) = divmacro(2*DYNX(W_,228),"2*heaPum.eva.tau",DYNX(W_,281),
  "heaPum.eva.rho_default");
DYNX(W_,257) = DYNX(W_,237);
DYNX(W_,258) = DYNX(W_,238);
DYNX(W_,282) = DYNX(DP_,33);
DYNX(W_,283) = DYNX(W_,232);
DYNX(W_,284) = 4184*(DYNX(W_,283)-273.15);
BoundParameterConstantSection
DYNX(W_,7) = 4184*(DYNX(DP_,1)-273.15);
DYNX(Aux_,0) = DYNX(W_,7);
DYNX(W_,39) = 4184*(DYNX(DP_,8)-273.15);
BreakSectionFunctionCallNew(0);
BreakSectionFunctionEnd()
BreakSectionFunctionStart(1);
DYNX(Aux_,1) = DYNX(W_,39);
DYNX(Aux_,2) = DYNX(W_,7);
DYNX(Aux_,3) = DYNX(W_,39);
DYNX(W_,21) = 4184*(DYNX(DP_,4)-273.15);
DYNX(Aux_,4) = DYNX(W_,21);
DYNX(W_,52) = 4184*(DYNX(DP_,13)-273.15);
DYNX(Aux_,5) = DYNX(W_,52);
DYNX(Aux_,6) = DYNX(W_,52);
DYNX(Aux_,7) = DYNX(W_,21);
DYNX(Aux_,8) = DYNX(W_,21);
DYNX(Aux_,9) = DYNX(W_,52);
DYNX(W_,149) = (PushModelContext(1,"AixLib.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(2.380952380952381, 0.030737963065138228, 0.2380952380952381)")
  AixLib_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow(
  2.380952380952381, 0.030737963065138228, 0.2380952380952381));
PopModelContext();
DYNX(W_,6) = DYNX(W_,149)+DYNX(DP_,6);
DYNX(W_,36) = DYNX(DP_,8)-273.15;
DYNX(W_,37) = 1E-05*DYNX(DP_,6);
DYNX(W_,50) = DYNX(DP_,13)-273.15;
DYNX(W_,51) = 1E-05*DYNX(DP_,11);
DYNX(W_,76) = DYNX(W_,6)-DYNX(DP_,6);
DYNX(W_,78) = 273.15+0.0002390057361376673*DYNX(W_,7);
DYNX(W_,80) = 273.15+0.0002390057361376673*DYNX(W_,21);
DYNX(W_,82) = 273.15+0.0002390057361376673*DYNX(W_,7);
DYNX(W_,83) = 273.15+0.0002390057361376673*DYNX(W_,39);
DYNX(W_,84) = 273.15+0.0002390057361376673*DYNX(W_,21);
DYNX(W_,85) = 273.15+0.0002390057361376673*DYNX(W_,52);
DYNX(W_,119) = 273.15+0.0002390057361376673*DYNX(W_,7);
DYNX(W_,121) = 273.15+0.0002390057361376673*DYNX(W_,21);
DYNX(W_,131) = DYNX(W_,6)-DYNX(DP_,6);
BoundParameterSection
InitialSection
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,19) = 0;
DYNX(W_,20) = 300000;
DYNX(W_,56) = 288.15;
DYNX(W_,67) = 83680.0;
DYNX(W_,69) = 83680.0;
DYNX(W_,79) = 293.15;
DYNX(W_,81) = 293.15;
DYNX(W_,115) = 288.15;
DYNX(W_,116) = 288.15;
DYNX(W_,120) = 293.15;
DYNX(W_,122) = 293.15;
DYNX(W_,220) = 0;
DYNX(W_,266) = 0;
#endif
InitialSection
InitialStartSection
InitialStartSection2
DYNX(W_,110) = 2+DYNX(DP_,23);
DYNX(W_,111) = DYNX(DP_,24)-2;
DYNX(W_,250) = DYNX(W_,238);
InitialSection
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
DefaultSection
InitializeData(0)
InitialSection
InitialSection2
DYNX(W_,56) = DYNX(DP_,18)+(IF LessTime(DYNX(DP_,19), 0) THEN 0 ELSE IF LessTime
  (DYNX(DP_,19)+DYNX(DP_,17), 1) THEN divmacro((DYNTime-DYNX(DP_,19))*
  DYNX(DP_,16),"(time-TConLvg.startTime)*TConLvg.height",DYNX(DP_,17),
  "TConLvg.duration") ELSE DYNX(DP_,16));
DYNX(W_,112) = Less(DYNX(W_,56),"TConLvg.y", DYNX(DP_,41),"heaPum.modi.threshold",
   0);
DYNX(W_,115) = IF DYNX(W_,112) THEN DYNX(DP_,24)-2 ELSE 2+DYNX(DP_,23);
DYNX(W_,91) = divmacro(0.3*DYNX(W_,115),"0.3*heaPum.TUseAct_nominal",4.0+
  DYNX(DP_,23)-DYNX(DP_,24),"4.0+heaPum.TCon_nominal-heaPum.TEva_nominal");
DYNX(W_,113) = IF DYNX(DP_,22) THEN 0.3 ELSE divmacro(DYNX(W_,91)*(4.0+
  DYNX(DP_,23)-DYNX(DP_,24)),"heaPum.COP_nominal*(4.0+heaPum.TCon_nominal-heaPum.TEva_nominal)",
  DYNX(W_,115),"heaPum.TUseAct_nominal");
AssertModelica(Less(DYNX(W_,113),"heaPum.etaCarnot_nominal_internal", 1,"1", 1),
  "heaPum.etaCarnot_nominal_internal < 1", "Parameters lead to etaCarnot_nominal > 1. Check parameters.");
DYNX(W_,195) = 4184*(DYNX(W_,56)-273.15);
DYNX(W_,198) = (PushModelContext(1,"AixLib.Utilities.Math.Functions.smoothLimit(heaPum.con.outCon.hSet-sou1.ports[1].h_outflow, -25200.0, 12600.0, heaPum.con.outCon.deltaH)")
  AixLib_Utilities_Math_Functions_smoothLimit(DYNX(W_,195)-DYNX(W_,7), -25200.0,
   12600.0, DYNX(W_,192)));
PopModelContext();
DYNX(W_,213) = 2.380952380952381*DYNX(W_,198);

 /* Linear system of equations to solve. */
/* Tag: initialization.linear[1] */
/* Introducing 1 common subexpressions used in 1 expressions */
/* Of the common subexpressions 1 are reals, 0 are integers, and 0
   are booleans. */
DYNX(DYNhelp,0) = IF DYNX(W_,112) THEN  -divmacro(1+DYNX(W_,91),"1+heaPum.COP_nominal",
  DYNX(W_,91),"heaPum.COP_nominal") ELSE 0.0;
DYNX(W_,87) = 0.0;
SolveScalarLinear(1.0-DYNX(DYNhelp,0)*(IF DYNX(W_,112) THEN 0.0 ELSE  -divmacro(
  DYNX(W_,91)-1,"heaPum.COP_nominal-1",DYNX(W_,91),"heaPum.COP_nominal")),
  "1.0-(if heaPum.COP_is_for_cooling then  -(1+heaPum.COP_nominal)/heaPum.COP_nominal else 0.0)*(if heaPum.COP_is_for_cooling then 0.0 else  -(heaPum.COP_nominal-1)/heaPum.COP_nominal)",
   (IF DYNX(W_,112) THEN 0.0 ELSE 100000.0)+DYNX(DYNhelp,0)*(IF DYNX(W_,112)
   THEN DYNX(DP_,40) ELSE 0.0),"(if heaPum.COP_is_for_cooling then 0.0 else 100000.0)+(if heaPum.COP_is_for_cooling then  -(1+heaPum.COP_nominal)/heaPum.COP_nominal else 0.0)*(if heaPum.COP_is_for_cooling then heaPum.Q_cooling_nominal else 0.0)",
   DYNX(W_,87),"heaPum.QCon_flow_nominal");
DYNX(W_,86) = IF DYNX(W_,112) THEN DYNX(DP_,40) ELSE  -divmacro(DYNX(W_,87)*(
  DYNX(W_,91)-1),"heaPum.QCon_flow_nominal*(heaPum.COP_nominal-1)",DYNX(W_,91),
  "heaPum.COP_nominal");
 /* End of Equation Block */ 

DYNX(W_,67) = DYNX(W_,7)+DYNX(W_,198);
DYNX(W_,120) = 273.15+0.0002390057361376673*DYNX(W_,67);
DYNX(W_,292) = IF DYNX(W_,112) THEN RealBmin(DYNX(W_,213), 0) ELSE RealBmax(
  DYNX(W_,213), 0);

{ /* Non-linear system of equations to solve. */
/* Tag: initialization.nonlinear[1] */
/* Introducing 25 common subexpressions used in 49 expressions */
/* Of the common subexpressions 23 are reals, 0 are integers, and 2
   are booleans. */
const char*const varnames_[]={"heaPum.TConAct", "heaPum.TEvaAct"};
const double nominal_[]={300.0, 300.0};
NonLinearSystemOfEquations(Jacobian__, residue__, x__, 2, 0, 1, -2, 
  DYNX(DYNhelp,1), 53, DYNX(did_->helpvari_vec,0), 24);
SetInitVector(x__, 1, DYNX(W_,110), 2+DYNX(DP_,23));
SetInitVector(x__, 2, DYNX(W_,111), DYNX(DP_,24)-2);
Residues;
  DYNX(W_,116) = IF DYNX(W_,112) THEN DYNX(W_,111) ELSE DYNX(W_,110);
  DYNX(DYNhelp,54) = 1+DYNX(W_,111)-DYNX(W_,110);
  DYNX(DYNhelp,55) = DYNX(DYNhelp,54) > 0.25;
  DYNX(DYNhelp,56) = IF DYNX(DYNhelp,55) THEN 1 ELSE IF DYNX(DYNhelp,54) < -0.25
     THEN DYNX(W_,110)-DYNX(W_,111) ELSE 0.5+0.25*(4.0+4.0*(DYNX(W_,111)-
    DYNX(W_,110)))*(sqr(4.0+4.0*(DYNX(W_,111)-DYNX(W_,110)))-3)*(DYNX(W_,110)-
    DYNX(W_,111)-1)+0.5*(DYNX(W_,110)-DYNX(W_,111));
  DYNX(DYNhelp,57) = divmacro(1.0,"1.0",DYNX(DYNhelp,56),"smooth(1, smooth(1, (if noEvent(1+heaPum.TEvaAct-heaPum.TConAct > 0.25) then 1 else (if noEvent(1+heaPum.TEvaAct-heaPum.TConAct < -0.25) then heaPum.TConAct-heaPum.TEvaAct else 0.5+0.25*((4.0+4.0*(heaPum.TEvaAct-heaPum.TConAct))*((4.0+4.0*(heaPum.TEvaAct-heaPum.TConAct))^2-3)*(heaPum.TConAct-heaPum.TEvaAct-1))+0.5*(heaPum.TConAct-heaPum.TEvaAct)))))");
  DYNX(W_,109) = DYNX(DYNhelp,57)*DYNX(W_,116);
  DYNX(W_,108) = DYNX(W_,113)*DYNX(W_,109);
  DYNX(W_,60) = IF DYNX(W_,112) THEN fabs(divmacro(RealBmin(DYNX(W_,213), 0),
    "min(heaPum.con.Q_flow, 0)",DYNX(W_,108),"heaPum.COP")) ELSE divmacro(
    RealBmax(DYNX(W_,213), 0),"max(heaPum.con.Q_flow, 0)",DYNX(W_,108),
    "heaPum.COP");
  DYNX(W_,286) = DYNX(DP_,42)*DYNX(W_,60)-DYNX(W_,292);
  DYNX(W_,105) = IF DYNX(W_,112) THEN RealBmin(0, DYNX(W_,213)) ELSE RealBmax(-60000,
     DYNX(W_,286));
  DYNX(W_,59) = IF DYNX(W_,112) THEN RealBmin(30000, DYNX(W_,286)) ELSE RealBmax
    (0, DYNX(W_,213));
  DYNX(W_,58) = DYNX(DP_,20)*DYNX(W_,59)+DYNX(DP_,21)*DYNX(W_,60);
  DYNX(W_,19) =  -DYNX(W_,57)*DYNX(W_,58);
  DYNX(DYNhelp,58) =  -DYNX(W_,19);
  DYNX(DYNhelp,59) = DYNX(DYNhelp,58) > 2.0000000000000002E-07 OR 
    DYNX(DYNhelp,58) < -2.0000000000000002E-07;
  DYNX(W_,307) = IF DYNX(DYNhelp,59) THEN  -divmacro(1,"1",DYNX(W_,19),
    "sou2.ports[1].m_flow") ELSE IF DYNX(DYNhelp,58) < 1.0000000000000001E-07
     AND DYNX(DYNhelp,58) > -1.0000000000000001E-07 THEN (-24999999999999.996)*
    DYNX(W_,19) ELSE (PushModelContext(1,"AixLib.Utilities.Math.Functions.BaseClasses.smoothTransition( -sou2.ports[1].m_flow, 2.0000000000000002E-07, 5000000.0, -75000000.0, 2.975E+15, -4.5125E+22, 3.3375E+29, -1.1875E+36, 1.625E+42)")
    AixLib_Utilities_Math_Functions_BaseClasses_smoothTransition(
    DYNX(DYNhelp,58), 2.0000000000000002E-07, 5000000.0, -75000000.0, 2.975E+15,
     -4.5125E+22, 3.3375E+29, -1.1875E+36, 1.625E+42));
  PopModelContext();
  DYNX(W_,69) = DYNX(Aux_,8)+DYNX(W_,286)*DYNX(W_,307);
  DYNX(W_,122) = 273.15+0.0002390057361376673*DYNX(W_,69);
DYNX(DYNhelp,60) = divmacro(1.0,"1.0",DYNX(W_,87),"heaPum.QCon_flow_nominal");
SetVector(residue__, 1, DYNX(W_,110)-(IF DYNX(W_,112) THEN DYNX(W_,122)+
  DYNX(DYNhelp,60)*2*DYNX(W_,59) ELSE DYNX(W_,120)+divmacro(2*DYNX(W_,59),
  "2*QEva_flow.u1",DYNX(W_,87),"heaPum.QCon_flow_nominal")));
SetVector(residue__, 2, DYNX(W_,111)-(IF DYNX(W_,112) THEN RealBmin(DYNX(W_,110)
  -10, DYNX(W_,120)-divmacro(2*DYNX(W_,105),"2*heaPum.QEva_flow",DYNX(W_,86),
  "heaPum.QEva_flow_nominal")) ELSE DYNX(W_,122)-divmacro(2*DYNX(W_,105),
  "2*heaPum.QEva_flow",DYNX(W_,86),"heaPum.QEva_flow_nominal")));

Jacobian(Jacobian__)
MatrixZeros(Jacobian__);
DYNX(DYNhelp,61) = IF DYNX(W_,112) THEN  -divmacro(RealBmin(DYNX(W_,213), 0)*(
  IF divmacro(RealBmin(DYNX(W_,213), 0),"min(heaPum.con.Q_flow, 0)",DYNX(W_,108),
  "heaPum.COP") > 0 THEN 1 ELSE -1),"min(heaPum.con.Q_flow, 0)*noEvent((if min(heaPum.con.Q_flow, 0)/heaPum.COP > 0 then 1 else -1))",
  sqr(DYNX(W_,108)),"heaPum.COP^2") ELSE  -divmacro(RealBmax(DYNX(W_,213), 0),
  "max(heaPum.con.Q_flow, 0)",sqr(DYNX(W_,108)),"heaPum.COP^2");
DYNX(DYNhelp,62) = IF DYNX(W_,112) THEN (IF 30000 < DYNX(W_,286) THEN 0.0 ELSE 
  1.0) ELSE 0.0;
DYNX(DYNhelp,63) = IF DYNX(DYNhelp,59) THEN divmacro(1,"1",sqr(DYNX(W_,19)),
  "sou2.ports[1].m_flow^2") ELSE IF DYNX(DYNhelp,58) < 1.0000000000000001E-07
   AND DYNX(DYNhelp,58) > -1.0000000000000001E-07 THEN -24999999999999.996 ELSE 
  (PushModelContext(1,"AixLib.Utilities.Math.Functions.BaseClasses.der_smoothTransition( -sou2.ports[1].m_flow, 2.0000000000000002E-07, 5000000.0, -75000000.0, 2.975E+15, -4.5125E+22, 3.3375E+29, -1.1875E+36, 1.625E+42, -1.0)")
  AixLib_Utilities_Math_Functions_BaseClasses_derx_0smoothTransition(
  DYNX(DYNhelp,58), 2.0000000000000002E-07, 5000000.0, -75000000.0, 2.975E+15, 
  -4.5125E+22, 3.3375E+29, -1.1875E+36, 1.625E+42, -1.0));
PopModelContext();
DYNX(DYNhelp,64) = IF DYNX(W_,112) THEN 1.0 ELSE 0.0;
DYNX(DYNhelp,65) = DYNX(W_,57)*DYNX(DYNhelp,63)*DYNX(W_,286)*DYNX(DYNhelp,64);
DYNX(DYNhelp,66) = 0.0002390057361376673*DYNX(DP_,20)*DYNX(DYNhelp,65);
DYNX(DYNhelp,67) = DYNX(DYNhelp,60)*2.0;
DYNX(DYNhelp,68) = DYNX(DYNhelp,61)*(DYNX(DP_,42)*(DYNX(DYNhelp,62)*(
  DYNX(DYNhelp,66)-DYNX(DYNhelp,67))-0.0002390057361376673*DYNX(W_,307)*
  DYNX(DYNhelp,64))+0.0002390057361376673*DYNX(DP_,21)*DYNX(DYNhelp,65));
DYNX(DYNhelp,69) = DYNX(W_,113)*DYNX(DYNhelp,68);
DYNX(DYNhelp,70) = IF DYNX(W_,112) THEN 0.0 ELSE 1.0;
DYNX(DYNhelp,71) = DYNX(W_,116)*(IF DYNX(DYNhelp,55) THEN 0.0 ELSE IF 
  DYNX(DYNhelp,54) < -0.25 THEN 1.0 ELSE 0.5+0.25*((DYNX(W_,110)-DYNX(W_,111)-1)
  *((4.0+4.0*(DYNX(W_,111)-DYNX(W_,110)))*((-32.0)-32.0*(DYNX(W_,111)-
  DYNX(W_,110)))-4.0*(sqr(4.0+4.0*(DYNX(W_,111)-DYNX(W_,110)))-3))+(4.0+4.0*(
  DYNX(W_,111)-DYNX(W_,110)))*(sqr(4.0+4.0*(DYNX(W_,111)-DYNX(W_,110)))-3)));
DYNX(DYNhelp,72) = sqr(DYNX(DYNhelp,56));
DYNX(DYNhelp,73) = divmacro(1.0,"1.0",DYNX(DYNhelp,72),"smooth(1, smooth(1, (if noEvent(1+heaPum.TEvaAct-heaPum.TConAct > 0.25) then 1 else (if noEvent(1+heaPum.TEvaAct-heaPum.TConAct < -0.25) then heaPum.TConAct-heaPum.TEvaAct else 0.5+0.25*((4.0+4.0*(heaPum.TEvaAct-heaPum.TConAct))*((4.0+4.0*(heaPum.TEvaAct-heaPum.TConAct))^2-3)*(heaPum.TConAct-heaPum.TEvaAct-1))+0.5*(heaPum.TConAct-heaPum.TEvaAct)))))^2");
DYNX(DYNhelp,74) = DYNX(W_,116)*(IF DYNX(DYNhelp,55) THEN 0.0 ELSE IF 
  DYNX(DYNhelp,54) < -0.25 THEN -1.0 ELSE 0.25*((DYNX(W_,110)-DYNX(W_,111)-1)*(
  4.0*(sqr(4.0+4.0*(DYNX(W_,111)-DYNX(W_,110)))-3)+(4.0+4.0*(DYNX(W_,111)-
  DYNX(W_,110)))*(32.0+32.0*(DYNX(W_,111)-DYNX(W_,110))))-(4.0+4.0*(DYNX(W_,111)
  -DYNX(W_,110)))*(sqr(4.0+4.0*(DYNX(W_,111)-DYNX(W_,110)))-3))-0.5);
DYNX(DYNhelp,75) = DYNX(W_,57)*DYNX(DYNhelp,63)*DYNX(W_,286)*DYNX(DYNhelp,70);
DYNX(DYNhelp,76) = DYNX(DYNhelp,62)*DYNX(DP_,20)*DYNX(DYNhelp,75);
DYNX(DYNhelp,77) = DYNX(DYNhelp,61)*(DYNX(DP_,42)*(0.0002390057361376673*
  DYNX(DYNhelp,76)-(IF DYNX(W_,112) THEN 0.0 ELSE IF -60000 > DYNX(W_,286) THEN 
  0.0 ELSE 1.0)*(IF DYNX(W_,112) THEN (IF DYNX(W_,110)-10 < DYNX(W_,120)-
  divmacro(2*DYNX(W_,105),"2*heaPum.QEva_flow",DYNX(W_,86),"heaPum.QEva_flow_nominal")
   THEN 0.0 ELSE  -divmacro(2.0,"2.0",DYNX(W_,86),"heaPum.QEva_flow_nominal"))
   ELSE  -divmacro(2.0,"2.0",DYNX(W_,86),"heaPum.QEva_flow_nominal"))-
  0.0002390057361376673*DYNX(W_,307)*DYNX(DYNhelp,70))+0.0002390057361376673*
  DYNX(DP_,21)*DYNX(DYNhelp,75));
DYNX(DYNhelp,78) = DYNX(W_,113)*DYNX(DYNhelp,77);
SetMatrixLeading(Jacobian__, 1, 1, 2, 1.0+DYNX(DYNhelp,57)*DYNX(DYNhelp,69)*
  DYNX(DYNhelp,70)-DYNX(DYNhelp,73)*DYNX(DYNhelp,69)*DYNX(DYNhelp,71));
SetMatrixLeading(Jacobian__, 1, 2, 2, DYNX(DYNhelp,57)*DYNX(DYNhelp,69)*
  DYNX(DYNhelp,64)-DYNX(DYNhelp,73)*DYNX(DYNhelp,69)*DYNX(DYNhelp,74));
SetMatrixLeading(Jacobian__, 2, 1, 2, DYNX(DYNhelp,57)*DYNX(DYNhelp,78)*
  DYNX(DYNhelp,70)-DYNX(DYNhelp,73)*DYNX(DYNhelp,78)*DYNX(DYNhelp,71)-(IF 
  DYNX(W_,112) THEN (IF DYNX(W_,110)-10 < DYNX(W_,120)-divmacro(2*DYNX(W_,105),
  "2*heaPum.QEva_flow",DYNX(W_,86),"heaPum.QEva_flow_nominal") THEN 1.0 ELSE 0.0)
   ELSE 0.0));
SetMatrixLeading(Jacobian__, 2, 2, 2, 1.0+DYNX(DYNhelp,57)*DYNX(DYNhelp,78)*
  DYNX(DYNhelp,64)-DYNX(DYNhelp,73)*DYNX(DYNhelp,78)*DYNX(DYNhelp,74));

SolveNonLinearSystemOfEquationsInit(Jacobian__, residue__, x__,"Tag: initialization.nonlinear[1]");
DYNX(W_,110) = GetVector(x__, 1);
DYNX(W_,111) = GetVector(x__, 2);
EndNonLinearSystemOfEquationsInit(residue__, x__, 1);
 /* End of Non-Linear Equation Block */ }



AssertModelica(Greater( -DYNX(W_,19)," -sou2.ports[1].m_flow", -0.0002,"-0.0002",
   2)," -sou2.ports[1].m_flow > -0.0002", StringAdd(StringAdd("Model has flow reversal, but the parameter allowFlowReversal is set to false.\n  m_flow_small    = 0.0002\n  ports[1].m_flow = ",
  Real2String2( -DYNX(W_,19), true, 0)),"\n"));
PopAllMarks();
AssertModelica(fabs(DYNX(W_,286)) < 836800.0*RealBmax(2.0000000000000002E-07, 
  fabs(DYNX(W_,19))),"noEvent(abs(heaPum.eva.u) < 836800.0*max(2.0000000000000002E-07, abs(sou2.ports[1].m_flow)))",
   StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(
  StringAdd("In Carnot_RE1.heaPum.eva.vol.steBal:\n   The heat flow rate equals ",
  Real2String2(DYNX(W_,286), true, 0))," W and the mass flow rate equals "),
  Real2String2( -DYNX(W_,19), true, 0))," kg/s,\n   which results in a temperature difference "),
  Real2String2(divmacro(fabs(DYNX(W_,286)),"abs(heaPum.eva.u)",836800.0*RealBmax
  (2.0000000000000002E-07, fabs(DYNX(W_,19))),"836800.0*max(2.0000000000000002E-07, abs(sou2.ports[1].m_flow))"),
   true, 0))," K > dTMax="),"200")," K.\n   This may indicate that energy is not conserved for small mass flow rates.\n   The implementation may require prescribedHeatFlowRate = false."));
PopAllMarks();
DYNX(W_,266) = homotopy((PushModelContext(1,"AixLib.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow( -sou2.ports[1].m_flow, 0.025819888974716113, 0.2)")
  AixLib_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow( -DYNX(W_,19),
   0.025819888974716113, 0.2)), (-3000.0)*DYNX(W_,19));
PopModelContext();
InitialSection
InitialSectionB
Init_=false;InitializeData(2);Init_=true;
InitialSection2
(PushModelContext(1,"Modelica.Fluid.Utilities.checkBoundary(\"SimpleLiquidWater\", {\"SimpleLiquidWater\"}, true, true, sou1.X_in_internal, \"Boundary_pT\")")
  Modelica_Fluid_Utilities_checkBoundary("SimpleLiquidWater", StringTemporaryDense( 
  DymArrays5, 1, 1), true, true, RealTemporaryDense( &DYNX(W_,9), 1, 1), 
  "Boundary_pT"));
PopAllMarks();
(PushModelContext(1,"Modelica.Fluid.Utilities.checkBoundary(\"SimpleLiquidWater\", {\"SimpleLiquidWater\"}, true, true, sou2.X_in_internal, \"Boundary_pT\")")
  Modelica_Fluid_Utilities_checkBoundary("SimpleLiquidWater", StringTemporaryDense( 
  DymArrays5, 1, 1), true, true, RealTemporaryDense( &DYNX(W_,23), 1, 1), 
  "Boundary_pT"));
PopAllMarks();
(PushModelContext(1,"Modelica.Fluid.Utilities.checkBoundary(\"SimpleLiquidWater\", {\"SimpleLiquidWater\"}, true, true, sin1.X, \"FixedBoundary\")")
  Modelica_Fluid_Utilities_checkBoundary("SimpleLiquidWater", StringTemporaryDense( 
  DymArrays5, 1, 1), true, true, RealTemporaryDense( &DYNX(DP_,10), 1, 1), 
  "FixedBoundary"));
PopAllMarks();
(PushModelContext(1,"Modelica.Fluid.Utilities.checkBoundary(\"SimpleLiquidWater\", {\"SimpleLiquidWater\"}, true, true, sin2.X, \"FixedBoundary\")")
  Modelica_Fluid_Utilities_checkBoundary("SimpleLiquidWater", StringTemporaryDense( 
  DymArrays5, 1, 1), true, true, RealTemporaryDense( &DYNX(DP_,15), 1, 1), 
  "FixedBoundary"));
PopAllMarks();
  AssertModelica(true,"true", StringAdd(StringAdd("The parameter tau, or the volume of the model from which tau may be derived, is unreasonably small.\n You need to set energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState to model steady-state.\n Received tau = ",
    Real2String2(DYNX(W_,228), true, 0)),"\n"));
  PopAllMarks();
  AssertModelica(true,"true", StringAdd(StringAdd("The parameter tau, or the volume of the model from which tau may be derived, is unreasonably small.\n You need to set massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState to model steady-state.\n Received tau = ",
    Real2String2(DYNX(W_,228), true, 0)),"\n"));
  PopAllMarks();
AssertModelica(fabs((PushModelContext(1,"AixLib.Utilities.Math.Functions.polynomial(1, heaPum.a)")
  AixLib_Utilities_Math_Functions_polynomial(1, RealTemporaryDense( &DYNX(W_,92),
   1, 1)))-1) < 0.01,"abs(AixLib.Utilities.Math.Functions.polynomial(1, heaPum.a)-1) < 0.01",
   "Efficiency curve is wrong. Need etaPL(y=1)=1.");
PopAllMarks();
EndInitialSection

OutputSection

DynamicsSection

AcceptedSection1
DYNX(W_,56) = DYNX(DP_,18)+(IF LessTime(DYNX(DP_,19), 0) THEN 0 ELSE IF LessTime
  (DYNX(DP_,19)+DYNX(DP_,17), 1) THEN divmacro((DYNTime-DYNX(DP_,19))*
  DYNX(DP_,16),"(time-TConLvg.startTime)*TConLvg.height",DYNX(DP_,17),
  "TConLvg.duration") ELSE DYNX(DP_,16));
DYNX(W_,112) = Less(DYNX(W_,56),"TConLvg.y", DYNX(DP_,41),"heaPum.modi.threshold",
   0);
DYNX(W_,195) = 4184*(DYNX(W_,56)-273.15);
DYNX(W_,198) = (PushModelContext(1,"AixLib.Utilities.Math.Functions.smoothLimit(heaPum.con.outCon.hSet-sou1.ports[1].h_outflow, -25200.0, 12600.0, heaPum.con.outCon.deltaH)")
  AixLib_Utilities_Math_Functions_smoothLimit(DYNX(W_,195)-DYNX(W_,7), -25200.0,
   12600.0, DYNX(W_,192)));
PopModelContext();
DYNX(W_,213) = 2.380952380952381*DYNX(W_,198);
DYNX(W_,115) = IF DYNX(W_,112) THEN DYNX(DP_,24)-2 ELSE 2+DYNX(DP_,23);
DYNX(W_,91) = divmacro(0.3*DYNX(W_,115),"0.3*heaPum.TUseAct_nominal",4.0+
  DYNX(DP_,23)-DYNX(DP_,24),"4.0+heaPum.TCon_nominal-heaPum.TEva_nominal");
DYNX(W_,113) = IF DYNX(DP_,22) THEN 0.3 ELSE divmacro(DYNX(W_,91)*(4.0+
  DYNX(DP_,23)-DYNX(DP_,24)),"heaPum.COP_nominal*(4.0+heaPum.TCon_nominal-heaPum.TEva_nominal)",
  DYNX(W_,115),"heaPum.TUseAct_nominal");

 /* Linear system of equations to solve. */
/* Tag: simulation.linear[1] */
/* Introducing 1 common subexpressions used in 1 expressions */
/* Of the common subexpressions 1 are reals, 0 are integers, and 0
   are booleans. */
DYNX(DYNhelp,79) = IF DYNX(W_,112) THEN  -divmacro(1+DYNX(W_,91),
  "1+heaPum.COP_nominal",DYNX(W_,91),"heaPum.COP_nominal") ELSE 0.0;
DYNX(W_,87) = RememberSimple_(DYNX(W_,87), 0);
SolveScalarLinear(1.0-DYNX(DYNhelp,79)*(IF DYNX(W_,112) THEN 0.0 ELSE  -divmacro
  (DYNX(W_,91)-1,"heaPum.COP_nominal-1",DYNX(W_,91),"heaPum.COP_nominal")),
  "1.0-(if heaPum.COP_is_for_cooling then  -(1+heaPum.COP_nominal)/heaPum.COP_nominal else 0.0)*(if heaPum.COP_is_for_cooling then 0.0 else  -(heaPum.COP_nominal-1)/heaPum.COP_nominal)",
   (IF DYNX(W_,112) THEN 0.0 ELSE 100000.0)+DYNX(DYNhelp,79)*(IF DYNX(W_,112)
   THEN DYNX(DP_,40) ELSE 0.0),"(if heaPum.COP_is_for_cooling then 0.0 else 100000.0)+(if heaPum.COP_is_for_cooling then  -(1+heaPum.COP_nominal)/heaPum.COP_nominal else 0.0)*(if heaPum.COP_is_for_cooling then heaPum.Q_cooling_nominal else 0.0)",
   DYNX(W_,87),"heaPum.QCon_flow_nominal");
DYNX(W_,86) = IF DYNX(W_,112) THEN DYNX(DP_,40) ELSE  -divmacro(DYNX(W_,87)*(
  DYNX(W_,91)-1),"heaPum.QCon_flow_nominal*(heaPum.COP_nominal-1)",DYNX(W_,91),
  "heaPum.COP_nominal");
 /* End of Equation Block */ 

DYNX(W_,67) = DYNX(W_,7)+DYNX(W_,198);
DYNX(W_,120) = 273.15+0.0002390057361376673*DYNX(W_,67);
DYNX(W_,292) = IF DYNX(W_,112) THEN RealBmin(DYNX(W_,213), 0) ELSE RealBmax(
  DYNX(W_,213), 0);

{ /* Non-linear system of equations to solve. */
/* Tag: simulation.nonlinear[1] */
/* Introducing 83 common subexpressions used in 49 expressions */
/* Of the common subexpressions 81 are reals, 0 are integers, and 2
   are booleans. */
const char*const varnames_[]={"heaPum.TConAct", "heaPum.TEvaAct"};
const double nominal_[]={300.0, 300.0};
NonLinearSystemOfEquationsNH(Jacobian__, residue__, x__, 2, 0, 2, -2, 7, 
  DYNX(DYNhelp,80), 67, DYNX(did_->helpvari_vec,24), 24);
NonLinearSystemSave(DYNX(W_,112), 0);
NonLinearSystemSave(DYNX(W_,87), 1);
NonLinearSystemSave(DYNX(W_,86), 2);
NonLinearSystemSave(DYNX(W_,213), 3);
NonLinearSystemSave(DYNX(W_,113), 4);
NonLinearSystemSave(DYNX(W_,292), 5);
NonLinearSystemSave(DYNX(W_,120), 6);
SetInitVectorNH(x__, 1, DYNX(W_,110), Remember_(DYNX(W_,110), 1));
SetInitVectorNH(x__, 2, DYNX(W_,111), Remember_(DYNX(W_,111), 2));
Residues;
  DYNX(W_,116) = IF DYNX(W_,112) THEN DYNX(W_,111) ELSE DYNX(W_,110);
  DYNX(DYNhelp,147) = 1+DYNX(W_,111)-DYNX(W_,110);
  DYNX(DYNhelp,148) = DYNX(DYNhelp,147) > 0.25;
  DYNX(DYNhelp,149) = IF DYNX(DYNhelp,148) THEN 1 ELSE IF DYNX(DYNhelp,147) < 
    -0.25 THEN DYNX(W_,110)-DYNX(W_,111) ELSE 0.5+0.25*(4.0+4.0*(DYNX(W_,111)-
    DYNX(W_,110)))*(sqr(4.0+4.0*(DYNX(W_,111)-DYNX(W_,110)))-3)*(DYNX(W_,110)-
    DYNX(W_,111)-1)+0.5*(DYNX(W_,110)-DYNX(W_,111));
  DYNX(DYNhelp,150) = divmacro(1.0,"1.0",DYNX(DYNhelp,149),"smooth(1, smooth(1, (if noEvent(1+heaPum.TEvaAct-heaPum.TConAct > 0.25) then 1 else (if noEvent(1+heaPum.TEvaAct-heaPum.TConAct < -0.25) then heaPum.TConAct-heaPum.TEvaAct else 0.5+0.25*((4.0+4.0*(heaPum.TEvaAct-heaPum.TConAct))*((4.0+4.0*(heaPum.TEvaAct-heaPum.TConAct))^2-3)*(heaPum.TConAct-heaPum.TEvaAct-1))+0.5*(heaPum.TConAct-heaPum.TEvaAct)))))");
  DYNX(W_,109) = DYNX(DYNhelp,150)*DYNX(W_,116);
  DYNX(W_,108) = DYNX(W_,113)*DYNX(W_,109);
  DYNX(W_,60) = IF DYNX(W_,112) THEN fabs(divmacro(RealBmin(DYNX(W_,213), 0),
    "min(heaPum.con.Q_flow, 0)",DYNX(W_,108),"heaPum.COP")) ELSE divmacro(
    RealBmax(DYNX(W_,213), 0),"max(heaPum.con.Q_flow, 0)",DYNX(W_,108),
    "heaPum.COP");
  DYNX(W_,286) = DYNX(DP_,42)*DYNX(W_,60)-DYNX(W_,292);
  DYNX(W_,105) = IF DYNX(W_,112) THEN RealBmin(0, DYNX(W_,213)) ELSE RealBmax(-60000,
     DYNX(W_,286));
  DYNX(W_,59) = IF DYNX(W_,112) THEN RealBmin(30000, DYNX(W_,286)) ELSE RealBmax
    (0, DYNX(W_,213));
  DYNX(W_,58) = DYNX(DP_,20)*DYNX(W_,59)+DYNX(DP_,21)*DYNX(W_,60);
  DYNX(W_,19) =  -DYNX(W_,57)*DYNX(W_,58);
  DYNX(DYNhelp,151) =  -DYNX(W_,19);
  DYNX(DYNhelp,152) = DYNX(DYNhelp,151) > 2.0000000000000002E-07 OR 
    DYNX(DYNhelp,151) < -2.0000000000000002E-07;
  DYNX(W_,307) = IF DYNX(DYNhelp,152) THEN  -divmacro(1,"1",DYNX(W_,19),
    "sou2.ports[1].m_flow") ELSE IF DYNX(DYNhelp,151) < 1.0000000000000001E-07
     AND DYNX(DYNhelp,151) > -1.0000000000000001E-07 THEN (-24999999999999.996)*
    DYNX(W_,19) ELSE (PushModelContext(1,"AixLib.Utilities.Math.Functions.BaseClasses.smoothTransition( -sou2.ports[1].m_flow, 2.0000000000000002E-07, 5000000.0, -75000000.0, 2.975E+15, -4.5125E+22, 3.3375E+29, -1.1875E+36, 1.625E+42)")
    AixLib_Utilities_Math_Functions_BaseClasses_smoothTransition(
    DYNX(DYNhelp,151), 2.0000000000000002E-07, 5000000.0, -75000000.0, 2.975E+15,
     -4.5125E+22, 3.3375E+29, -1.1875E+36, 1.625E+42));
  PopModelContext();
  DYNX(W_,69) = DYNX(Aux_,8)+DYNX(W_,286)*DYNX(W_,307);
  DYNX(W_,122) = 273.15+0.0002390057361376673*DYNX(W_,69);
DYNX(DYNhelp,153) = divmacro(1.0,"1.0",DYNX(W_,87),"heaPum.QCon_flow_nominal");
SetVector(residue__, 1, DYNX(W_,110)-(IF DYNX(W_,112) THEN DYNX(W_,122)+
  DYNX(DYNhelp,153)*2*DYNX(W_,59) ELSE DYNX(W_,120)+divmacro(2*DYNX(W_,59),
  "2*QEva_flow.u1",DYNX(W_,87),"heaPum.QCon_flow_nominal")));
SetVector(residue__, 2, DYNX(W_,111)-(IF DYNX(W_,112) THEN RealBmin(DYNX(W_,110)
  -10, DYNX(W_,120)-divmacro(2*DYNX(W_,105),"2*heaPum.QEva_flow",DYNX(W_,86),
  "heaPum.QEva_flow_nominal")) ELSE DYNX(W_,122)-divmacro(2*DYNX(W_,105),
  "2*heaPum.QEva_flow",DYNX(W_,86),"heaPum.QEva_flow_nominal")));

Jacobian(Jacobian__)
MatrixZeros(Jacobian__);
DYNX(DYNhelp,154) = IF DYNX(W_,112) THEN  -divmacro(RealBmin(DYNX(W_,213), 0)*(
  IF divmacro(RealBmin(DYNX(W_,213), 0),"min(heaPum.con.Q_flow, 0)",DYNX(W_,108),
  "heaPum.COP") > 0 THEN 1 ELSE -1),"min(heaPum.con.Q_flow, 0)*noEvent((if min(heaPum.con.Q_flow, 0)/heaPum.COP > 0 then 1 else -1))",
  sqr(DYNX(W_,108)),"heaPum.COP^2") ELSE  -divmacro(RealBmax(DYNX(W_,213), 0),
  "max(heaPum.con.Q_flow, 0)",sqr(DYNX(W_,108)),"heaPum.COP^2");
DYNX(DYNhelp,155) = IF DYNX(W_,112) THEN (IF 30000 < DYNX(W_,286) THEN 0.0 ELSE 
  1.0) ELSE 0.0;
DYNX(DYNhelp,156) = IF DYNX(DYNhelp,152) THEN divmacro(1,"1",sqr(DYNX(W_,19)),
  "sou2.ports[1].m_flow^2") ELSE IF DYNX(DYNhelp,151) < 1.0000000000000001E-07
   AND DYNX(DYNhelp,151) > -1.0000000000000001E-07 THEN -24999999999999.996
   ELSE (PushModelContext(1,"AixLib.Utilities.Math.Functions.BaseClasses.der_smoothTransition( -sou2.ports[1].m_flow, 2.0000000000000002E-07, 5000000.0, -75000000.0, 2.975E+15, -4.5125E+22, 3.3375E+29, -1.1875E+36, 1.625E+42, -1.0)")
  AixLib_Utilities_Math_Functions_BaseClasses_derx_0smoothTransition(
  DYNX(DYNhelp,151), 2.0000000000000002E-07, 5000000.0, -75000000.0, 2.975E+15, 
  -4.5125E+22, 3.3375E+29, -1.1875E+36, 1.625E+42, -1.0));
PopModelContext();
DYNX(DYNhelp,157) = IF DYNX(W_,112) THEN 1.0 ELSE 0.0;
DYNX(DYNhelp,158) = DYNX(W_,57)*DYNX(DYNhelp,156)*DYNX(W_,286)*DYNX(DYNhelp,157);
DYNX(DYNhelp,159) = 0.0002390057361376673*DYNX(DP_,20)*DYNX(DYNhelp,158);
DYNX(DYNhelp,160) = DYNX(DYNhelp,153)*2.0;
DYNX(DYNhelp,161) = DYNX(DYNhelp,154)*(DYNX(DP_,42)*(DYNX(DYNhelp,155)*(
  DYNX(DYNhelp,159)-DYNX(DYNhelp,160))-0.0002390057361376673*DYNX(W_,307)*
  DYNX(DYNhelp,157))+0.0002390057361376673*DYNX(DP_,21)*DYNX(DYNhelp,158));
DYNX(DYNhelp,162) = DYNX(W_,113)*DYNX(DYNhelp,161);
DYNX(DYNhelp,163) = IF DYNX(W_,112) THEN 0.0 ELSE 1.0;
DYNX(DYNhelp,164) = DYNX(W_,116)*(IF DYNX(DYNhelp,148) THEN 0.0 ELSE IF 
  DYNX(DYNhelp,147) < -0.25 THEN 1.0 ELSE 0.5+0.25*((DYNX(W_,110)-DYNX(W_,111)-1)
  *((4.0+4.0*(DYNX(W_,111)-DYNX(W_,110)))*((-32.0)-32.0*(DYNX(W_,111)-
  DYNX(W_,110)))-4.0*(sqr(4.0+4.0*(DYNX(W_,111)-DYNX(W_,110)))-3))+(4.0+4.0*(
  DYNX(W_,111)-DYNX(W_,110)))*(sqr(4.0+4.0*(DYNX(W_,111)-DYNX(W_,110)))-3)));
DYNX(DYNhelp,165) = sqr(DYNX(DYNhelp,149));
DYNX(DYNhelp,166) = divmacro(1.0,"1.0",DYNX(DYNhelp,165),"smooth(1, smooth(1, (if noEvent(1+heaPum.TEvaAct-heaPum.TConAct > 0.25) then 1 else (if noEvent(1+heaPum.TEvaAct-heaPum.TConAct < -0.25) then heaPum.TConAct-heaPum.TEvaAct else 0.5+0.25*((4.0+4.0*(heaPum.TEvaAct-heaPum.TConAct))*((4.0+4.0*(heaPum.TEvaAct-heaPum.TConAct))^2-3)*(heaPum.TConAct-heaPum.TEvaAct-1))+0.5*(heaPum.TConAct-heaPum.TEvaAct)))))^2");
DYNX(DYNhelp,167) = DYNX(W_,116)*(IF DYNX(DYNhelp,148) THEN 0.0 ELSE IF 
  DYNX(DYNhelp,147) < -0.25 THEN -1.0 ELSE 0.25*((DYNX(W_,110)-DYNX(W_,111)-1)*(
  4.0*(sqr(4.0+4.0*(DYNX(W_,111)-DYNX(W_,110)))-3)+(4.0+4.0*(DYNX(W_,111)-
  DYNX(W_,110)))*(32.0+32.0*(DYNX(W_,111)-DYNX(W_,110))))-(4.0+4.0*(DYNX(W_,111)
  -DYNX(W_,110)))*(sqr(4.0+4.0*(DYNX(W_,111)-DYNX(W_,110)))-3))-0.5);
DYNX(DYNhelp,168) = DYNX(W_,57)*DYNX(DYNhelp,156)*DYNX(W_,286)*DYNX(DYNhelp,163);
DYNX(DYNhelp,169) = DYNX(DYNhelp,155)*DYNX(DP_,20)*DYNX(DYNhelp,168);
DYNX(DYNhelp,170) = DYNX(DYNhelp,154)*(DYNX(DP_,42)*(0.0002390057361376673*
  DYNX(DYNhelp,169)-(IF DYNX(W_,112) THEN 0.0 ELSE IF -60000 > DYNX(W_,286)
   THEN 0.0 ELSE 1.0)*(IF DYNX(W_,112) THEN (IF DYNX(W_,110)-10 < DYNX(W_,120)-
  divmacro(2*DYNX(W_,105),"2*heaPum.QEva_flow",DYNX(W_,86),"heaPum.QEva_flow_nominal")
   THEN 0.0 ELSE  -divmacro(2.0,"2.0",DYNX(W_,86),"heaPum.QEva_flow_nominal"))
   ELSE  -divmacro(2.0,"2.0",DYNX(W_,86),"heaPum.QEva_flow_nominal"))-
  0.0002390057361376673*DYNX(W_,307)*DYNX(DYNhelp,163))+0.0002390057361376673*
  DYNX(DP_,21)*DYNX(DYNhelp,168));
DYNX(DYNhelp,171) = DYNX(W_,113)*DYNX(DYNhelp,170);
SetMatrixLeading(Jacobian__, 1, 1, 2, 1.0+DYNX(DYNhelp,150)*DYNX(DYNhelp,162)*
  DYNX(DYNhelp,163)-DYNX(DYNhelp,166)*DYNX(DYNhelp,162)*DYNX(DYNhelp,164));
SetMatrixLeading(Jacobian__, 1, 2, 2, DYNX(DYNhelp,150)*DYNX(DYNhelp,162)*
  DYNX(DYNhelp,157)-DYNX(DYNhelp,166)*DYNX(DYNhelp,162)*DYNX(DYNhelp,167));
SetMatrixLeading(Jacobian__, 2, 1, 2, DYNX(DYNhelp,150)*DYNX(DYNhelp,171)*
  DYNX(DYNhelp,163)-DYNX(DYNhelp,166)*DYNX(DYNhelp,171)*DYNX(DYNhelp,164)-(IF 
  DYNX(W_,112) THEN (IF DYNX(W_,110)-10 < DYNX(W_,120)-divmacro(2*DYNX(W_,105),
  "2*heaPum.QEva_flow",DYNX(W_,86),"heaPum.QEva_flow_nominal") THEN 1.0 ELSE 0.0)
   ELSE 0.0));
SetMatrixLeading(Jacobian__, 2, 2, 2, 1.0+DYNX(DYNhelp,150)*DYNX(DYNhelp,171)*
  DYNX(DYNhelp,157)-DYNX(DYNhelp,166)*DYNX(DYNhelp,171)*DYNX(DYNhelp,167));

SolveNonLinearSystemOfEquationsNH(Jacobian__, residue__, x__, 2, 
  "Tag: simulation.nonlinear[1]");
DYNX(W_,110) = GetVector(x__, 1);
DYNX(W_,111) = GetVector(x__, 2);
EndNonLinearSystemOfEquationsNH(residue__, x__, 2);
 /* End of Non-Linear Equation Block */ }



AssertModelica(Greater( -DYNX(W_,19)," -sou2.ports[1].m_flow", -0.0002,"-0.0002",
   2)," -sou2.ports[1].m_flow > -0.0002", StringAdd(StringAdd("Model has flow reversal, but the parameter allowFlowReversal is set to false.\n  m_flow_small    = 0.0002\n  ports[1].m_flow = ",
  Real2String2( -DYNX(W_,19), true, 0)),"\n"));
PopAllMarks();
AssertModelica(fabs(DYNX(W_,286)) < 836800.0*RealBmax(2.0000000000000002E-07, 
  fabs(DYNX(W_,19))),"noEvent(abs(heaPum.eva.u) < 836800.0*max(2.0000000000000002E-07, abs(sou2.ports[1].m_flow)))",
   StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(
  StringAdd("In Carnot_RE1.heaPum.eva.vol.steBal:\n   The heat flow rate equals ",
  Real2String2(DYNX(W_,286), true, 0))," W and the mass flow rate equals "),
  Real2String2( -DYNX(W_,19), true, 0))," kg/s,\n   which results in a temperature difference "),
  Real2String2(divmacro(fabs(DYNX(W_,286)),"abs(heaPum.eva.u)",836800.0*RealBmax
  (2.0000000000000002E-07, fabs(DYNX(W_,19))),"836800.0*max(2.0000000000000002E-07, abs(sou2.ports[1].m_flow))"),
   true, 0))," K > dTMax="),"200")," K.\n   This may indicate that energy is not conserved for small mass flow rates.\n   The implementation may require prescribedHeatFlowRate = false."));
PopAllMarks();

AcceptedSection2
DYNX(W_,266) = (PushModelContext(1,"AixLib.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow( -sou2.ports[1].m_flow, 0.025819888974716113, 0.2)")
  AixLib_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow( -DYNX(W_,19),
   0.025819888974716113, 0.2));
PopModelContext();
DYNX(W_,20) = DYNX(W_,266)+DYNX(DP_,11);
DYNX(W_,77) = DYNX(W_,20)-DYNX(DP_,11);
DYNX(W_,79) = 273.15+0.0002390057361376673*DYNX(W_,67);
DYNX(W_,81) = 273.15+0.0002390057361376673*DYNX(W_,69);
DYNX(W_,106) = IF DYNX(W_,112) THEN divmacro(DYNX(W_,105),"heaPum.QEva_flow",
  DYNX(W_,86),"heaPum.QEva_flow_nominal") ELSE divmacro(DYNX(W_,59),
  "QEva_flow.u1",DYNX(W_,87),"heaPum.QCon_flow_nominal");
DYNX(W_,220) = DYNX(W_,20)-DYNX(DP_,11);
DYNX(W_,250) = 273.15+0.0002390057361376673*DYNX(W_,69);

DefaultSection
InitializeData(1)
EndTranslatedEquations

#include <dsblock6.c>

PreNonAliasNew(0)
StartNonAlias(0)
DeclareParameter("dTEva_nominal", "Temperature difference evaporator inlet-outlet [K,]",\
 0, -5, 0.0,0.0,0.0,0,560)
DeclareVariable("dTCon_nominal", "Temperature difference condenser outlet-inlet [K,]",\
 10, 0.0,0.0,0.0,0,513)
DeclareVariable("QCon_flow_nominal", "Evaporator heat flow rate [W]", 100000.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("m1_flow_nominal", "Nominal mass flow rate at condenser [kg/s]",\
 2.380952380952381, 0.0,0.0,0.0,0,513)
DeclareVariable("sou1.nPorts", "Number of ports [:#(type=Integer)]", 1, 0.0,0.0,\
0.0,0,517)
DeclareVariable("sou1.verifyInputs", "Set to true to stop the simulation with an error if the medium temperature is outside its allowable range [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("sou1.ports[1].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 -2.380952380952381, -1E+60,1E+60,0.0,0,777)
DeclareVariable("sou1.ports[1].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 300000, 0.0,100000000.0,100000.0,0,521)
DeclareVariable("sou1.ports[1].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 83680.0, -10000000000.0,10000000000.0,1000000.0,0,521)
DeclareVariable("sou1.flowDirection", "Allowed flow direction [:#(type=Modelica.Fluid.Types.PortFlowDirection)]",\
 3, 1.0,3.0,0.0,0,2565)
DeclareAlias2("sou1.p_in_internal", "Needed to connect to conditional connector [Pa]",\
 "sou1.ports[1].p", 1, 5, 6, 1024)
DeclareVariable("sou1.X_in_internal[1]", "Needed to connect to conditional connector [kg/kg]",\
 1.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("sou1.use_m_flow_in", "Get the mass flow rate from the input connector [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("sou1.m_flow", "Fixed mass flow rate going out of the fluid port [kg/s]",\
 2.380952380952381, 0.0,0.0,0.0,0,513)
DeclareVariable("sou1.m_flow_in_internal", "Needed to connect to conditional connector [kg/s]",\
 2.380952380952381, 0.0,0.0,0.0,0,2561)
DeclareVariable("sou1.use_T_in", "Get the temperature from the input connector [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareParameter("sou1.T", "Fixed value of temperature [K|degC]", 1, 293.15, 1.0,\
10000.0,300.0,0,560)
DeclareAlias2("sou1.T_in_internal", "Needed to connect to conditional connector [K|degC]",\
 "sou1.T", 1, 7, 1, 1024)
DeclareAlias2("sou1.h_internal", "", "sou1.ports[1].h_outflow", 1, 5, 7, 1024)
DeclareVariable("sou1.use_X_in", "Get the composition (all fractions) from the input connector [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("sou1.use_Xi_in", "Get the composition (independent fractions) from the input connector [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("sou1.use_C_in", "Get the trace substances from the input connector [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareParameter("sou1.X[1]", "Fixed value of composition [kg/kg]", 2, 1, 0.0,\
1.0,0.1,0,560)
DeclareVariable("sou2.nPorts", "Number of ports [:#(type=Integer)]", 1, 0.0,0.0,\
0.0,0,517)
DeclareVariable("sou2.verifyInputs", "Set to true to stop the simulation with an error if the medium temperature is outside its allowable range [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("sou2.ports[1].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 0, -100000.0,0.0,2.0,0,776)
DeclareVariable("sou2.ports[1].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 300000, 0.0,100000000.0,100000.0,0,520)
DeclareVariable("sou2.ports[1].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 83680.0, -10000000000.0,10000000000.0,1000000.0,0,521)
DeclareVariable("sou2.flowDirection", "Allowed flow direction [:#(type=Modelica.Fluid.Types.PortFlowDirection)]",\
 3, 1.0,3.0,0.0,0,2565)
DeclareAlias2("sou2.p_in_internal", "Needed to connect to conditional connector [Pa]",\
 "sou2.ports[1].p", 1, 5, 20, 1024)
DeclareVariable("sou2.X_in_internal[1]", "Needed to connect to conditional connector [kg/kg]",\
 1.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("sou2.use_m_flow_in", "Get the mass flow rate from the input connector [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,1539)
DeclareParameter("sou2.m_flow", "Fixed mass flow rate going out of the fluid port [kg/s]",\
 3, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("sou2.m_flow_in", "Prescribed mass flow rate [kg/s]", \
"sou2.ports[1].m_flow", -1, 5, 19, 0)
DeclareAlias2("sou2.m_flow_in_internal", "Needed to connect to conditional connector [kg/s]",\
 "sou2.ports[1].m_flow", -1, 5, 19, 1024)
DeclareVariable("sou2.use_T_in", "Get the temperature from the input connector [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareParameter("sou2.T", "Fixed value of temperature [K|degC]", 4, 288.15, 1.0,\
10000.0,300.0,0,560)
DeclareAlias2("sou2.T_in_internal", "Needed to connect to conditional connector [K|degC]",\
 "sou2.T", 1, 7, 4, 1024)
DeclareAlias2("sou2.h_internal", "", "sou2.ports[1].h_outflow", 1, 5, 21, 1024)
DeclareVariable("sou2.use_X_in", "Get the composition (all fractions) from the input connector [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("sou2.use_Xi_in", "Get the composition (independent fractions) from the input connector [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("sou2.use_C_in", "Get the trace substances from the input connector [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareParameter("sou2.X[1]", "Fixed value of composition [kg/kg]", 5, 1, 0.0,\
1.0,0.1,0,560)
DeclareVariable("sin1.nPorts", "Number of ports [:#(type=Integer)]", 1, 0.0,0.0,\
0.0,0,517)
DeclareAlias2("sin1.medium.T", "Temperature of medium [K|degC]", "sin1.T", 1, 7,\
 8, 0)
DeclareAlias2("sin1.medium.p", "Absolute pressure of medium [Pa|bar]", "sin1.p", 1,\
 7, 6, 0)
DeclareAlias2("sin1.medium.h", "Specific enthalpy of medium [J/kg]", \
"sin1.ports[1].h_outflow", 1, 5, 39, 0)
DeclareAlias2("sin1.medium.u", "Specific internal energy of medium [J/kg]", \
"sin1.ports[1].h_outflow", 1, 5, 39, 0)
DeclareVariable("sin1.medium.d", "Density of medium [kg/m3|g/cm3]", 995.586, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("sin1.medium.X[1]", "Mass fractions (= (component mass)/total mass  m_i/m) [1]",\
 1, 0.0,1.0,0.0,0,513)
DeclareVariable("sin1.medium.R", "Gas constant (of mixture if applicable) [J/(kg.K)]",\
 0, 0.0,0.0,0.0,0,513)
DeclareVariable("sin1.medium.MM", "Molar mass (of mixture or single fluid) [kg/mol]",\
 0.018015268, 0.0,1E+100,0.0,0,513)
DeclareAlias2("sin1.medium.state.p", "Absolute pressure of medium [Pa|bar]", \
"sin1.p", 1, 7, 6, 0)
DeclareAlias2("sin1.medium.state.T", "Temperature of medium [K|degC]", "sin1.T", 1,\
 7, 8, 0)
DeclareVariable("sin1.medium.preferredMediumStates", "= true if StateSelect.prefer shall be used for the independent property variables of the medium [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("sin1.medium.standardOrderComponents", "If true, and reducedX = true, the last element of X will be computed from the other ones [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("sin1.medium.T_degC", "Temperature of medium in [degC] [degC;]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("sin1.medium.p_bar", "Absolute pressure of medium in [bar] [bar]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("sin1.ports[1].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 2.380952380952381, -1E+60,1E+60,0.0,0,777)
DeclareAlias2("sin1.ports[1].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "sin1.p", 1, 7, 6, 4)
DeclareVariable("sin1.ports[1].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 83680.0, -10000000000.0,10000000000.0,1000000.0,0,521)
DeclareVariable("sin1.flowDirection", "Allowed flow direction [:#(type=Modelica.Fluid.Types.PortFlowDirection)]",\
 3, 1.0,3.0,0.0,0,2565)
DeclareVariable("sin1.use_p", "select p or d [:#(type=Boolean)]", true, 0.0,0.0,\
0.0,0,515)
DeclareParameter("sin1.p", "Boundary pressure [Pa|bar]", 6, 300000, 0.0,\
100000000.0,100000.0,0,560)
DeclareParameter("sin1.d", "Boundary density [kg/m3|g/cm3]", 7, 995.586, 0.0,\
100000.0,1.0,0,560)
DeclareVariable("sin1.use_T", "select T or h [:#(type=Boolean)]", true, 0.0,0.0,\
0.0,0,515)
DeclareParameter("sin1.T", "Boundary temperature [K|degC]", 8, 293.15, 1.0,\
10000.0,300.0,0,560)
DeclareParameter("sin1.h", "Boundary specific enthalpy [J/kg]", 9, 83680.0, \
-10000000000.0,10000000000.0,1000000.0,0,560)
DeclareParameter("sin1.X[1]", "Boundary mass fractions m_i/m [kg/kg]", 10, 1, \
0.0,1.0,0.1,0,560)
DeclareVariable("sin2.nPorts", "Number of ports [:#(type=Integer)]", 1, 0.0,0.0,\
0.0,0,517)
DeclareAlias2("sin2.medium.T", "Temperature of medium [K|degC]", "sin2.T", 1, 7,\
 13, 0)
DeclareAlias2("sin2.medium.p", "Absolute pressure of medium [Pa|bar]", "sin2.p", 1,\
 7, 11, 0)
DeclareAlias2("sin2.medium.h", "Specific enthalpy of medium [J/kg]", \
"sin2.ports[1].h_outflow", 1, 5, 52, 0)
DeclareAlias2("sin2.medium.u", "Specific internal energy of medium [J/kg]", \
"sin2.ports[1].h_outflow", 1, 5, 52, 0)
DeclareVariable("sin2.medium.d", "Density of medium [kg/m3|g/cm3]", 995.586, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("sin2.medium.X[1]", "Mass fractions (= (component mass)/total mass  m_i/m) [1]",\
 1, 0.0,1.0,0.0,0,513)
DeclareVariable("sin2.medium.R", "Gas constant (of mixture if applicable) [J/(kg.K)]",\
 0, 0.0,0.0,0.0,0,513)
DeclareVariable("sin2.medium.MM", "Molar mass (of mixture or single fluid) [kg/mol]",\
 0.018015268, 0.0,1E+100,0.0,0,513)
DeclareAlias2("sin2.medium.state.p", "Absolute pressure of medium [Pa|bar]", \
"sin2.p", 1, 7, 11, 0)
DeclareAlias2("sin2.medium.state.T", "Temperature of medium [K|degC]", "sin2.T", 1,\
 7, 13, 0)
DeclareVariable("sin2.medium.preferredMediumStates", "= true if StateSelect.prefer shall be used for the independent property variables of the medium [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("sin2.medium.standardOrderComponents", "If true, and reducedX = true, the last element of X will be computed from the other ones [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("sin2.medium.T_degC", "Temperature of medium in [degC] [degC;]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("sin2.medium.p_bar", "Absolute pressure of medium in [bar] [bar]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("sin2.ports[1].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "sou2.ports[1].m_flow", -1, 5, 19, 132)
DeclareAlias2("sin2.ports[1].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "sin2.p", 1, 7, 11, 4)
DeclareVariable("sin2.ports[1].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 0.0, -10000000000.0,10000000000.0,1000000.0,0,521)
DeclareVariable("sin2.flowDirection", "Allowed flow direction [:#(type=Modelica.Fluid.Types.PortFlowDirection)]",\
 3, 1.0,3.0,0.0,0,2565)
DeclareVariable("sin2.use_p", "select p or d [:#(type=Boolean)]", true, 0.0,0.0,\
0.0,0,515)
DeclareParameter("sin2.p", "Boundary pressure [Pa|bar]", 11, 300000, 0.0,\
100000000.0,100000.0,0,560)
DeclareParameter("sin2.d", "Boundary density [kg/m3|g/cm3]", 12, 995.586, 0.0,\
100000.0,1.0,0,560)
DeclareVariable("sin2.use_T", "select T or h [:#(type=Boolean)]", true, 0.0,0.0,\
0.0,0,515)
DeclareParameter("sin2.T", "Boundary temperature [K|degC]", 13, 293.15, 1.0,\
10000.0,300.0,0,560)
DeclareParameter("sin2.h", "Boundary specific enthalpy [J/kg]", 14, 83680.0, \
-10000000000.0,10000000000.0,1000000.0,0,560)
DeclareParameter("sin2.X[1]", "Boundary mass fractions m_i/m [kg/kg]", 15, 1, \
0.0,1.0,0.1,0,560)
DeclareParameter("TConLvg.height", "Height of ramps", 16, 15, 0.0,0.0,0.0,0,560)
DeclareParameter("TConLvg.duration", "Duration of ramp (= 0.0 gives a Step) [s]",\
 17, 60, 0.0,1E+100,0.0,0,560)
DeclareParameter("TConLvg.offset", "Offset of output signal", 18, 308.15, \
0.0,0.0,0.0,0,560)
DeclareParameter("TConLvg.startTime", "Output = offset for time < startTime [s]",\
 19, 1800, 0.0,0.0,0.0,0,560)
DeclareVariable("TConLvg.y", "Connector of Real output signal", 288.15, 0.0,\
1E+100,300.0,0,512)
DeclareVariable("mEva_flow.k", "Gain value multiplied with input signal [1]", 1,\
 0.0,0.0,0.0,0,513)
DeclareVariable("mEva_flow.u", "Input signal connector", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("mEva_flow.y", "Output signal connector", "sou2.ports[1].m_flow", -1,\
 5, 19, 0)
DeclareVariable("QEva_flow.u1", "Connector of Real input signal 1", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("QEva_flow.u2", "Connector of Real input signal 2", 0.0, \
0.0,0.0,0.0,0,512)
DeclareAlias2("QEva_flow.y", "Connector of Real output signal", "mEva_flow.u", 1,\
 5, 58, 0)
DeclareParameter("QEva_flow.k1", "Gain of upper input", 20, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("QEva_flow.k2", "Gain of lower input", 21, -1, 0.0,0.0,0.0,0,560)
DeclareVariable("cp2_default", "Specific heat capacity of medium 2 at default medium state [J/(kg.K)]",\
 4184, 0.0,0.0,0.0,0,513)
DeclareVariable("heaPum.allowFlowReversal1", "= false to simplify equations, assuming, but not enforcing, no flow reversal for medium 1 [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("heaPum.allowFlowReversal2", "= false to simplify equations, assuming, but not enforcing, no flow reversal for medium 2 [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("heaPum.port_a1.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 2.380952380952381, 0.0,100000.0,0.0,0,777)
DeclareAlias2("heaPum.port_a1.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "sou1.ports[1].p", 1, 5, 6, 4)
DeclareVariable("heaPum.port_a1.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 83680.0, -10000000000.0,10000000000.0,83680.0,0,521)
DeclareVariable("heaPum.port_b1.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 -2.380952380952381, -100000.0,0.0,0.0,0,777)
DeclareAlias2("heaPum.port_b1.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "sin1.p", 1, 7, 6, 4)
DeclareVariable("heaPum.port_b1.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 83680.0, -10000000000.0,10000000000.0,83680.0,0,520)
DeclareAlias2("heaPum.port_a2.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "sou2.ports[1].m_flow", -1, 5, 19, 132)
DeclareAlias2("heaPum.port_a2.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "sou2.ports[1].p", 1, 5, 20, 4)
DeclareVariable("heaPum.port_a2.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 83680.0, -10000000000.0,10000000000.0,83680.0,0,521)
DeclareAlias2("heaPum.port_b2.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "sou2.ports[1].m_flow", 1, 5, 19, 132)
DeclareAlias2("heaPum.port_b2.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "sin2.p", 1, 7, 11, 4)
DeclareVariable("heaPum.port_b2.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 83680.0, -10000000000.0,10000000000.0,83680.0,0,520)
DeclareVariable("heaPum.m1_flow_nominal", "Nominal mass flow rate [kg/s]", \
2.380952380952381, 0.0,1E+100,0.0,0,513)
DeclareVariable("heaPum.m2_flow_nominal", "Nominal mass flow rate [kg/s]", 2, \
0.0,1E+100,0.0,0,513)
DeclareVariable("heaPum.m1_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 0.0002380952380952381, 0.0,100000.0,0.0,0,513)
DeclareVariable("heaPum.m2_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 0.0002, 0.0,100000.0,0.0,0,513)
DeclareVariable("heaPum.show_T", "= true, if actual temperature at port is computed [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("heaPum.m1_flow", "Mass flow rate from port_a1 to port_b1 (m1_flow > 0 is design flow direction) [kg/s]",\
 2.380952380952381, -100000.0,100000.0,0.0,0,513)
DeclareVariable("heaPum.dp1", "Pressure difference between port_a1 and port_b1 [Pa|Pa]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("heaPum.m2_flow", "Mass flow rate from port_a2 to port_b2 (m2_flow > 0 is design flow direction) [kg/s]",\
 "sou2.ports[1].m_flow", -1, 5, 19, 0)
DeclareVariable("heaPum.dp2", "Pressure difference between port_a2 and port_b2 [Pa|Pa]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("heaPum.sta_a1.p", "Absolute pressure of medium [Pa|bar]", \
"sou1.ports[1].p", 1, 5, 6, 0)
DeclareVariable("heaPum.sta_a1.T", "Temperature of medium [K|degC]", 293.15, 1.0,\
10000.0,300.0,0,513)
DeclareAlias2("heaPum.sta_b1.p", "Absolute pressure of medium [Pa|bar]", \
"sin1.p", 1, 7, 6, 0)
DeclareVariable("heaPum.sta_b1.T", "Temperature of medium [K|degC]", 293.15, 1.0,\
10000.0,300.0,0,512)
DeclareAlias2("heaPum.sta_a2.p", "Absolute pressure of medium [Pa|bar]", \
"sou2.ports[1].p", 1, 5, 20, 0)
DeclareVariable("heaPum.sta_a2.T", "Temperature of medium [K|degC]", 293.15, 1.0,\
10000.0,300.0,0,513)
DeclareAlias2("heaPum.sta_b2.p", "Absolute pressure of medium [Pa|bar]", \
"sin2.p", 1, 7, 11, 0)
DeclareVariable("heaPum.sta_b2.T", "Temperature of medium [K|degC]", 293.15, 1.0,\
10000.0,300.0,0,512)
DeclareAlias2("heaPum.state_a1_inflow.p", "Absolute pressure of medium [Pa|bar]",\
 "sou1.ports[1].p", 1, 5, 6, 1024)
DeclareVariable("heaPum.state_a1_inflow.T", "Temperature of medium [K|degC]", \
293.15, 1.0,10000.0,300.0,0,2561)
DeclareAlias2("heaPum.state_b1_inflow.p", "Absolute pressure of medium [Pa|bar]",\
 "sin1.p", 1, 7, 6, 1024)
DeclareVariable("heaPum.state_b1_inflow.T", "Temperature of medium [K|degC]", \
293.15, 1.0,10000.0,300.0,0,2561)
DeclareAlias2("heaPum.state_a2_inflow.p", "Absolute pressure of medium [Pa|bar]",\
 "sou2.ports[1].p", 1, 5, 20, 1024)
DeclareVariable("heaPum.state_a2_inflow.T", "Temperature of medium [K|degC]", \
293.15, 1.0,10000.0,300.0,0,2561)
DeclareAlias2("heaPum.state_b2_inflow.p", "Absolute pressure of medium [Pa|bar]",\
 "sin2.p", 1, 7, 11, 1024)
DeclareVariable("heaPum.state_b2_inflow.T", "Temperature of medium [K|degC]", \
293.15, 1.0,10000.0,300.0,0,2561)
DeclareVariable("heaPum.QEva_flow_nominal", "Nominal cooling heat flow rate (QEva_flow_nominal < 0) [W]",\
 0.0, -1E+100,0.0,0.0,0,640)
DeclareVariable("heaPum.QCon_flow_nominal", "Nominal heating flow rate [W]", 0.0,\
 0.0,1E+100,0.0,0,640)
DeclareVariable("heaPum.dTEva_nominal", "Temperature difference evaporator outlet-inlet [K,]",\
 0.0, -1E+100,0.0,0.0,0,513)
DeclareVariable("heaPum.dTCon_nominal", "Temperature difference condenser outlet-inlet [K,]",\
 10, 0.0,1E+100,0.0,0,513)
DeclareParameter("heaPum.use_eta_Carnot_nominal", "Set to true to use Carnot effectiveness etaCarnot_nominal rather than COP_nominal [:#(type=Boolean)]",\
 22, true, 0.0,0.0,0.0,0,562)
DeclareVariable("heaPum.etaCarnot_nominal", "Carnot effectiveness (=COP/COP_Carnot) used if use_eta_Carnot_nominal = true [1]",\
 0.3, 0.0,0.0,0.0,0,513)
DeclareVariable("heaPum.COP_nominal", "Coefficient of performance at TEva_nominal and TCon_nominal, used if use_eta_Carnot_nominal = false [1]",\
 0.0, 0.0,0.0,0.0,0,640)
DeclareParameter("heaPum.TCon_nominal", "Condenser temperature used to compute COP_nominal if use_eta_Carnot_nominal=false [K|degC]",\
 23, 303.15, 0.0,1E+100,300.0,0,560)
DeclareParameter("heaPum.TEva_nominal", "Evaporator temperature used to compute COP_nominal if use_eta_Carnot_nominal=false [K|degC]",\
 24, 278.15, 0.0,1E+100,300.0,0,560)
DeclareVariable("heaPum.a[1]", "Coefficients for efficiency curve (need p(a=a, yPL=1)=1)",\
 1.0, 0.0,0.0,0.0,0,513)
DeclareVariable("heaPum.dp1_nominal", "Pressure difference over condenser [Pa|Pa]",\
 6000, 0.0,0.0,0.0,0,513)
DeclareVariable("heaPum.dp2_nominal", "Pressure difference over evaporator [Pa|Pa]",\
 6000, 0.0,0.0,0.0,0,513)
DeclareVariable("heaPum.TAppCon_nominal", "Temperature difference between refrigerant and working fluid outlet in condenser [K,]",\
 2, 0.0,1E+100,0.0,0,513)
DeclareVariable("heaPum.TAppEva_nominal", "Temperature difference between refrigerant and working fluid outlet in evaporator [K,]",\
 2, 0.0,1E+100,0.0,0,513)
DeclareVariable("heaPum.homotopyInitialization", "= true, use homotopy method [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("heaPum.from_dp1", "= true, use m_flow = f(dp) else dp = f(m_flow) [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("heaPum.from_dp2", "= true, use m_flow = f(dp) else dp = f(m_flow) [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("heaPum.linearizeFlowResistance1", "= true, use linear relation between m_flow and dp for any flow rate [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("heaPum.linearizeFlowResistance2", "= true, use linear relation between m_flow and dp for any flow rate [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("heaPum.deltaM1", "Fraction of nominal flow rate where flow transitions to laminar [1]",\
 0.1, 0.0,0.0,0.0,0,513)
DeclareVariable("heaPum.deltaM2", "Fraction of nominal flow rate where flow transitions to laminar [1]",\
 0.1, 0.0,0.0,0.0,0,513)
DeclareParameter("heaPum.tau1", "Time constant at nominal flow rate (used if energyDynamics1 <> Modelica.Fluid.Types.Dynamics.SteadyState) [s]",\
 25, 60, 0.0,0.0,0.0,0,560)
DeclareParameter("heaPum.tau2", "Time constant at nominal flow rate (used if energyDynamics2 <> Modelica.Fluid.Types.Dynamics.SteadyState) [s]",\
 26, 60, 0.0,0.0,0.0,0,560)
DeclareParameter("heaPum.T1_start", "Initial or guess value of set point [K|degC]",\
 27, 293.15, 0.0,1E+100,300.0,0,560)
DeclareParameter("heaPum.T2_start", "Initial or guess value of set point [K|degC]",\
 28, 293.15, 0.0,1E+100,300.0,0,560)
DeclareVariable("heaPum.energyDynamics", "Type of energy balance: dynamic (3 initialization options) or steady state [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareAlias2("heaPum.QCon_flow", "Actual heating heat flow rate added to fluid 1 [W]",\
 "QEva_flow.u1", 1, 5, 59, 0)
DeclareAlias2("heaPum.P", "Electric power consumed by compressor [W]", \
"QEva_flow.u2", 1, 5, 60, 0)
DeclareVariable("heaPum.QEva_flow", "Actual cooling heat flow rate removed from fluid 2 [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("heaPum.yPL", "Part load ratio [1]", 0.0, 0.0,1E+100,0.0,0,512)
DeclareVariable("heaPum.etaPL", "Efficiency due to part load (etaPL(yPL=1)=1) [1]",\
 1, 0.0,0.0,0.0,0,513)
DeclareVariable("heaPum.COP", "Coefficient of performance [1]", 0.0, 0.0,1E+100,\
0.0,0,512)
DeclareVariable("heaPum.COPCar", "Carnot efficiency", 0.0, 0.0,1E+100,0.0,0,512)
DeclareVariable("heaPum.TConAct", "Condenser temperature used to compute efficiency, taking into account pinch temperature between fluid and refrigerant [K|degC]",\
 0.0, 0.0,1E+100,300.0,0,512)
DeclareVariable("heaPum.TEvaAct", "Evaporator temperature used to compute efficiency, taking into account pinch temperature between fluid and refrigerant [K|degC]",\
 0.0, 0.0,1E+100,300.0,0,512)
DeclareVariable("heaPum.COP_is_for_cooling", "Set to true if the specified COP is for cooling [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,642)
DeclareVariable("heaPum.etaCarnot_nominal_internal", "Carnot effectiveness (=COP/COP_Carnot) used to compute COP [1]",\
 0.0, 0.0,0.0,0.0,0,2688)
DeclareVariable("heaPum.evaluate_etaPL", "Flag, true if etaPL should be computed as it depends on yPL [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("heaPum.TUseAct_nominal", "Nominal evaporator temperature for chiller or condenser temperature for heat pump, taking into account pinch temperature between fluid and refrigerant [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,2688)
DeclareVariable("heaPum.TUseAct", "Temperature of useful heat (evaporator for chiller, condenser for heat pump), taking into account pinch temperature between fluid and refrigerant [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,2560)
DeclareVariable("heaPum.cp1_default", "Specific heat capacity of medium 1 at default medium state [J/(kg.K)]",\
 4184, 0.0,0.0,0.0,0,2561)
DeclareVariable("heaPum.cp2_default", "Specific heat capacity of medium 2 at default medium state [J/(kg.K)]",\
 4184, 0.0,0.0,0.0,0,2561)
DeclareAlias2("heaPum.staA1.p", "Absolute pressure of medium [Pa|bar]", \
"sou1.ports[1].p", 1, 5, 6, 1024)
DeclareVariable("heaPum.staA1.T", "Temperature of medium [K|degC]", 293.15, 1.0,\
10000.0,300.0,0,2561)
DeclareAlias2("heaPum.staB1.p", "Absolute pressure of medium [Pa|bar]", "sin1.p", 1,\
 7, 6, 1024)
DeclareVariable("heaPum.staB1.T", "Temperature of medium [K|degC]", 293.15, 1.0,\
10000.0,300.0,0,2560)
DeclareAlias2("heaPum.staA2.p", "Absolute pressure of medium [Pa|bar]", \
"sou2.ports[1].p", 1, 5, 20, 1024)
DeclareVariable("heaPum.staA2.T", "Temperature of medium [K|degC]", 293.15, 1.0,\
10000.0,300.0,0,2561)
DeclareAlias2("heaPum.staB2.p", "Absolute pressure of medium [Pa|bar]", "sin2.p", 1,\
 7, 11, 1024)
DeclareVariable("heaPum.staB2.T", "Temperature of medium [K|degC]", 293.15, 1.0,\
10000.0,300.0,0,2560)
DeclareVariable("heaPum.con.allowFlowReversal", "= false to simplify equations, assuming, but not enforcing, no flow reversal [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("heaPum.con.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 2.380952380952381, 0.0,100000.0,0.0,0,2825)
DeclareAlias2("heaPum.con.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "sou1.ports[1].p", 1, 5, 6, 1028)
DeclareVariable("heaPum.con.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 83680.0, -10000000000.0,10000000000.0,83680.0,0,2569)
DeclareVariable("heaPum.con.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 -2.380952380952381, -100000.0,0.0,0.0,0,2825)
DeclareAlias2("heaPum.con.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "sin1.p", 1, 7, 6, 1028)
DeclareAlias2("heaPum.con.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "heaPum.port_b1.h_outflow", 1, 5, 67, 1028)
DeclareVariable("heaPum.con.m_flow_nominal", "Nominal mass flow rate [kg/s]", \
2.380952380952381, 0.0,0.0,0.0,0,2561)
DeclareVariable("heaPum.con.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 0.0001, 0.0,1E+100,0.0,0,2561)
DeclareVariable("heaPum.con.show_T", "= true, if actual temperature at port is computed [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("heaPum.con.m_flow", "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction) [kg/s]",\
 2.380952380952381, 0.0,0.0,0.0,0,2561)
DeclareVariable("heaPum.con.dp", "Pressure difference between port_a and port_b [Pa|Pa]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("heaPum.con._m_flow_start", "Start value for m_flow, used to avoid a warning if not set in m_flow, and to avoid m_flow.start in parameter window [kg/s]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("heaPum.con._dp_start", "Start value for dp, used to avoid a warning if not set in dp, and to avoid dp.start in parameter window [Pa|Pa]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("heaPum.con.computeFlowResistance", "=true, compute flow resistance. Set to false to assume no friction [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("heaPum.con.from_dp", "= true, use m_flow = f(dp) else dp = f(m_flow) [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("heaPum.con.dp_nominal", "Pressure difference [Pa|Pa]", 6000, \
0.0,1E+100,0.0,0,2561)
DeclareVariable("heaPum.con.linearizeFlowResistance", "= true, use linear relation between m_flow and dp for any flow rate [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("heaPum.con.deltaM", "Fraction of nominal flow rate where flow transitions to laminar",\
 0.1, 0.0,0.0,0.0,0,2561)
DeclareVariable("heaPum.con.tau", "Time constant at nominal flow rate (used if energyDynamics or massDynamics not equal Modelica.Fluid.Types.Dynamics.SteadyState) [s]",\
 0.0, 0.0,1E+100,0.0,0,2561)
DeclareVariable("heaPum.con.homotopyInitialization", "= true, use homotopy method [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("heaPum.con.preDro.allowFlowReversal", "= false to simplify equations, assuming, but not enforcing, no flow reversal [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("heaPum.con.preDro.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 2.380952380952381, 0.0,100000.0,0.0,0,2825)
DeclareAlias2("heaPum.con.preDro.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "sou1.ports[1].p", 1, 5, 6, 1028)
DeclareVariable("heaPum.con.preDro.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 83680.0, -10000000000.0,10000000000.0,83680.0,0,2569)
DeclareVariable("heaPum.con.preDro.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 -2.380952380952381, -100000.0,0.0,0.0,0,2825)
DeclareAlias2("heaPum.con.preDro.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "sin1.p", 1, 7, 6, 1028)
DeclareAlias2("heaPum.con.preDro.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "sou1.ports[1].h_outflow", 1, 5, 7, 1028)
DeclareVariable("heaPum.con.preDro.m_flow_nominal", "Nominal mass flow rate [kg/s]",\
 2.380952380952381, 0.0,0.0,0.0,0,2561)
DeclareVariable("heaPum.con.preDro.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 0.0002380952380952381, 0.0,1E+100,0.0,0,2561)
DeclareVariable("heaPum.con.preDro.show_T", "= true, if actual temperature at port is computed [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("heaPum.con.preDro.m_flow", "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction) [kg/s]",\
 2.380952380952381, 0.0,0.0,2.380952380952381,0,2561)
DeclareVariable("heaPum.con.preDro.dp", "Pressure difference between port_a and port_b [Pa|Pa]",\
 0, 0.0,0.0,6000.0,0,2561)
DeclareVariable("heaPum.con.preDro._m_flow_start", "Start value for m_flow, used to avoid a warning if not set in m_flow, and to avoid m_flow.start in parameter window [kg/s]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("heaPum.con.preDro._dp_start", "Start value for dp, used to avoid a warning if not set in dp, and to avoid dp.start in parameter window [Pa|Pa]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("heaPum.con.preDro.from_dp", "= true, use m_flow = f(dp) else dp = f(m_flow) [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("heaPum.con.preDro.dp_nominal", "Pressure drop at nominal mass flow rate [Pa|Pa]",\
 6000, 0.0,0.0,0.0,0,2561)
DeclareVariable("heaPum.con.preDro.homotopyInitialization", "= true, use homotopy method [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("heaPum.con.preDro.linearized", "= true, use linear relation between m_flow and dp for any flow rate [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("heaPum.con.preDro.m_flow_turbulent", "Turbulent flow if |m_flow| >= m_flow_turbulent [kg/s]",\
 0.2380952380952381, 0.0,1E+100,0.0,0,2561)
DeclareParameter("heaPum.con.preDro.sta_default.p", "Absolute pressure of medium [Pa|bar]",\
 29, 300000.0, 0.0,100000000.0,100000.0,0,2608)
DeclareParameter("heaPum.con.preDro.sta_default.T", "Temperature of medium [K|degC]",\
 30, 293.15, 1.0,10000.0,300.0,0,2608)
DeclareVariable("heaPum.con.preDro.eta_default", "Dynamic viscosity, used to compute transition to turbulent flow regime [Pa.s]",\
 0.001, 0.0,1E+100,0.0,0,2561)
DeclareVariable("heaPum.con.preDro.m_flow_nominal_pos", "Absolute value of nominal flow rate [kg/s]",\
 2.380952380952381, 0.0,0.0,0.0,0,2561)
DeclareVariable("heaPum.con.preDro.dp_nominal_pos", "Absolute value of nominal pressure difference [Pa|Pa]",\
 6000, 0.0,0.0,0.0,0,2561)
DeclareVariable("_GlobalScope.Modelica.Media.Interfaces.PartialPureSubstance.X_default[1]",\
 "Default value for mass fractions of medium (for initialization) [kg/kg]", 1, \
0.0,1.0,0.1,0,2561)
DeclareVariable("heaPum.con.preDro.deltaM", "Fraction of nominal mass flow rate where transition to turbulent occurs",\
 0.1, 1E-06,1E+100,0.0,0,2561)
DeclareVariable("heaPum.con.preDro.k", "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)",\
 0.030737963065138228, 0.0,0.0,0.0,0,2561)
DeclareVariable("heaPum.con.preDro.computeFlowResistance", "Flag to enable/disable computation of flow resistance [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("heaPum.con.preDro.coeff", "Precomputed coefficient to avoid division by parameter",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("heaPum.con.outCon.allowFlowReversal", "= false to simplify equations, assuming, but not enforcing, no flow reversal [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("heaPum.con.outCon.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 2.380952380952381, 0.0,100000.0,0.0,0,2825)
DeclareAlias2("heaPum.con.outCon.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "sin1.p", 1, 7, 6, 1028)
DeclareVariable("heaPum.con.outCon.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 83680.0, -10000000000.0,10000000000.0,83680.0,0,2569)
DeclareVariable("heaPum.con.outCon.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 -2.380952380952381, -100000.0,0.0,0.0,0,2825)
DeclareAlias2("heaPum.con.outCon.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "sin1.p", 1, 7, 6, 1028)
DeclareAlias2("heaPum.con.outCon.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "heaPum.port_b1.h_outflow", 1, 5, 67, 1028)
DeclareVariable("heaPum.con.outCon.m_flow_nominal", "Nominal mass flow rate [kg/s]",\
 2.380952380952381, 0.0,0.0,0.0,0,2561)
DeclareVariable("heaPum.con.outCon.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 0.0001, 0.0,1E+100,0.0,0,2561)
DeclareVariable("heaPum.con.outCon.show_T", "= true, if actual temperature at port is computed [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("heaPum.con.outCon.m_flow", "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction) [kg/s]",\
 2.380952380952381, 0.0,0.0,0.0,0,2561)
DeclareVariable("heaPum.con.outCon.dp", "Pressure difference between port_a and port_b [Pa|Pa]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("heaPum.con.outCon._m_flow_start", "Start value for m_flow, used to avoid a warning if not set in m_flow, and to avoid m_flow.start in parameter window [kg/s]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("heaPum.con.outCon._dp_start", "Start value for dp, used to avoid a warning if not set in dp, and to avoid dp.start in parameter window [Pa|Pa]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("heaPum.con.outCon.QMax_flow", "Maximum heat flow rate for heating (positive) [W]",\
 30000.0, 0.0,1E+100,0.0,0,2561)
DeclareVariable("heaPum.con.outCon.QMin_flow", "Maximum heat flow rate for cooling (negative) [W]",\
 -60000.0, -1E+100,0.0,0.0,0,2561)
DeclareVariable("heaPum.con.outCon.mWatMax_flow", "Maximum water mass flow rate addition (positive) [kg/s]",\
 0.0, 0.0,1E+100,0.0,0,2561)
DeclareVariable("heaPum.con.outCon.mWatMin_flow", "Maximum water mass flow rate removal (negative) [kg/s]",\
 0.0, -1E+100,0.0,0.0,0,2561)
DeclareVariable("heaPum.con.outCon.tau", "Time constant at nominal flow rate (used if energyDynamics or massDynamics not equal Modelica.Fluid.Types.Dynamics.SteadyState) [s]",\
 0.0, 0.0,1E+100,0.0,0,2561)
DeclareVariable("heaPum.con.outCon.T_start", "Start value of temperature [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,2561)
DeclareVariable("heaPum.con.outCon.X_start[1]", "Start value of mass fractions m_i/m [1]",\
 1.0, 0.0,1.0,0.0,0,2561)
DeclareVariable("heaPum.con.outCon.energyDynamics", "Type of energy balance: dynamic (3 initialization options) or steady state [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 4, 1.0,4.0,0.0,0,2565)
DeclareVariable("heaPum.con.outCon.massDynamics", "Type of mass balance: dynamic (3 initialization options) or steady state [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 4, 1.0,4.0,0.0,0,2565)
DeclareVariable("heaPum.con.outCon.use_TSet", "Set to false to disable temperature set point [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("heaPum.con.outCon.use_X_wSet", "Set to false to disable water vapor set point [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareAlias2("heaPum.con.outCon.Q_flow", "Heat flow rate added to the fluid (if flow is from port_a to port_b) [W]",\
 "heaPum.con.Q_flow", 1, 5, 213, 1024)
DeclareVariable("heaPum.con.outCon.mWat_flow", "Water vapor mass flow rate added to the fluid (if flow is from port_a to port_b) [kg/s]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareParameter("heaPum.con.outCon.cp_default", "Specific heat capacity at default medium state [J/(kg.K)]",\
 31, 4184, 0.0,0.0,0.0,0,2608)
DeclareVariable("heaPum.con.outCon.restrictHeat", "Flag, true if maximum heating power is restricted [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("heaPum.con.outCon.restrictCool", "Flag, true if maximum cooling power is restricted [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("heaPum.con.outCon.restrictHumi", "Flag, true if maximum humidification is restricted [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("heaPum.con.outCon.restrictDehu", "Flag, true if maximum dehumidification is restricted [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("heaPum.con.outCon.deltaH", "Small value for deltaH used for regularization [J/kg]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareParameter("heaPum.con.outCon.deltaXi", "Small mass fraction used for regularization [1]",\
 32, 1E-06, 0.0,1.0,0.0,0,2608)
DeclareVariable("heaPum.con.outCon.m_flow_pos", "Mass flow rate, or zero if reverse flow [kg/s]",\
 2.380952380952381, 0.0,0.0,0.0,0,2561)
DeclareVariable("heaPum.con.outCon.m_flow_non_zero", "Mass flow rate bounded away from zero [kg/s]",\
 2.380952380952381, 0.0,0.0,0.0,0,2561)
DeclareVariable("heaPum.con.outCon.hSet", "Set point for enthalpy leaving port_b [J/kg]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareAlias2("heaPum.con.outCon.T", "Temperature of outlet state assuming unlimited capacity and taking dynamics into account [K|degC]",\
 "TConLvg.y", 1, 5, 56, 1024)
DeclareVariable("heaPum.con.outCon.Xi", "Water vapor mass fraction of outlet state assuming unlimited capacity and taking dynamics into account [1]",\
 0.01, 0.0,1.0,0.0,0,2561)
DeclareVariable("heaPum.con.outCon.Xi_outflow", "Outstreaming water vapor mass fraction at port_a [1]",\
 0.0, 0.0,1.0,0.0,0,2561)
DeclareVariable("heaPum.con.outCon.dhAct", "Actual enthalpy difference from port_a to port_b [J/kg]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("heaPum.con.outCon.dXiAct", "Actual mass fraction difference from port_a to port_b [1]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("heaPum.con.outCon.k", "Gain to take flow rate into account for sensor time constant",\
 1.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("heaPum.con.outCon.mNor_flow", "Normalized mass flow rate", 1.0,\
 0.0,0.0,0.0,0,2561)
DeclareAlias2("heaPum.con.outCon.TSet_internal", "Internal connector for set point temperature of the fluid that leaves port_b [K|degC]",\
 "TConLvg.y", 1, 5, 56, 1024)
DeclareVariable("heaPum.con.outCon.X_wSet_internal", "Internal connector for set point for water vapor mass fraction of the fluid that leaves port_b [1]",\
 0.01, 0.0,0.0,0.0,0,2561)
DeclareVariable("heaPum.con.QMax_flow", "Maximum heat flow rate for heating (positive) [W]",\
 30000.0, 0.0,1E+100,0.0,0,2561)
DeclareVariable("heaPum.con.QMin_flow", "Maximum heat flow rate for cooling (negative) [W]",\
 -60000.0, -1E+100,0.0,0.0,0,2561)
DeclareVariable("heaPum.con.mWatMax_flow", "Maximum water mass flow rate addition (positive) [kg/s]",\
 0, 0.0,1E+100,0.0,0,2561)
DeclareVariable("heaPum.con.mWatMin_flow", "Maximum water mass flow rate removal (negative) [kg/s]",\
 0, -1E+100,0.0,0.0,0,2561)
DeclareVariable("heaPum.con.T_start", "Start value of temperature [K|degC]", \
288.15, 0.0,1E+100,300.0,0,2561)
DeclareVariable("heaPum.con.X_start[1]", "Start value of mass fractions m_i/m [1]",\
 1, 0.0,1.0,0.0,0,2561)
DeclareVariable("heaPum.con.energyDynamics", "Type of energy balance: dynamic (3 initialization options) or steady state [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 4, 1.0,4.0,0.0,0,2565)
DeclareVariable("heaPum.con.massDynamics", "Type of mass balance: dynamic (3 initialization options) or steady state [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 4, 1.0,4.0,0.0,0,2565)
DeclareVariable("heaPum.con.use_TSet", "Set to false to disable temperature set point [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("heaPum.con.use_X_wSet", "Set to false to disable water vapor set point [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareAlias2("heaPum.con.TSet", "Set point temperature of the fluid that leaves port_b [K|degC]",\
 "TConLvg.y", 1, 5, 56, 1024)
DeclareVariable("heaPum.con.Q_flow", "Heat flow rate added to the fluid (if flow is from port_a to port_b) [W]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("heaPum.con.mWat_flow", "Water vapor mass flow rate added to the fluid (if flow is from port_a to port_b) [kg/s]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("heaPum.eva.allowFlowReversal", "= false to simplify equations, assuming, but not enforcing, no flow reversal [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareAlias2("heaPum.eva.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "sou2.ports[1].m_flow", -1, 5, 19, 1156)
DeclareAlias2("heaPum.eva.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "sou2.ports[1].p", 1, 5, 20, 1028)
DeclareVariable("heaPum.eva.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 83680.0, -10000000000.0,10000000000.0,83680.0,0,2569)
DeclareAlias2("heaPum.eva.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "sou2.ports[1].m_flow", 1, 5, 19, 1156)
DeclareAlias2("heaPum.eva.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "sin2.p", 1, 7, 11, 1028)
DeclareAlias2("heaPum.eva.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "heaPum.port_b2.h_outflow", 1, 5, 69, 1028)
DeclareVariable("heaPum.eva.m_flow_nominal", "Nominal mass flow rate [kg/s]", 2,\
 0.0,0.0,0.0,0,2561)
DeclareVariable("heaPum.eva.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 0.0001, 0.0,1E+100,0.0,0,2561)
DeclareVariable("heaPum.eva.show_T", "= true, if actual temperature at port is computed [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareAlias2("heaPum.eva.m_flow", "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction) [kg/s]",\
 "sou2.ports[1].m_flow", -1, 5, 19, 1024)
DeclareVariable("heaPum.eva.dp", "Pressure difference between port_a and port_b [Pa|Pa]",\
 0, 0.0,0.0,0.0,0,2560)
DeclareVariable("heaPum.eva._m_flow_start", "Start value for m_flow, used to avoid a warning if not set in m_flow, and to avoid m_flow.start in parameter window [kg/s]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("heaPum.eva._dp_start", "Start value for dp, used to avoid a warning if not set in dp, and to avoid dp.start in parameter window [Pa|Pa]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("heaPum.eva.computeFlowResistance", "=true, compute flow resistance. Set to false to assume no friction [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("heaPum.eva.from_dp", "= true, use m_flow = f(dp) else dp = f(m_flow) [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("heaPum.eva.dp_nominal", "Pressure difference [Pa|Pa]", 6000, \
0.0,1E+100,0.0,0,2561)
DeclareVariable("heaPum.eva.linearizeFlowResistance", "= true, use linear relation between m_flow and dp for any flow rate [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("heaPum.eva.deltaM", "Fraction of nominal flow rate where flow transitions to laminar",\
 0.1, 0.0,0.0,0.0,0,2561)
DeclareVariable("heaPum.eva.tau", "Time constant at nominal flow (if energyDynamics <> SteadyState) [s]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("heaPum.eva.homotopyInitialization", "= true, use homotopy method [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("heaPum.eva.energyDynamics", "Type of energy balance: dynamic (3 initialization options) or steady state [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 4, 1.0,4.0,0.0,0,2565)
DeclareVariable("heaPum.eva.massDynamics", "Type of mass balance: dynamic (3 initialization options) or steady state [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 4, 1.0,4.0,0.0,0,2565)
DeclareParameter("heaPum.eva.p_start", "Start value of pressure [Pa|bar]", 33, 300000,\
 0.0,100000000.0,100000.0,0,2608)
DeclareVariable("heaPum.eva.T_start", "Start value of temperature [K|degC]", \
293.15, 1.0,10000.0,300.0,0,2561)
DeclareParameter("heaPum.eva.X_start[1]", "Start value of mass fractions m_i/m [kg/kg]",\
 34, 1, 0.0,1.0,0.1,0,2608)
DeclareVariable("heaPum.eva.vol.energyDynamics", "Type of energy balance: dynamic (3 initialization options) or steady state [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 4, 1.0,4.0,0.0,0,2565)
DeclareVariable("heaPum.eva.vol.massDynamics", "Type of mass balance: dynamic (3 initialization options) or steady state [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 4, 1.0,4.0,0.0,0,2565)
DeclareVariable("heaPum.eva.vol.substanceDynamics", "Type of independent mass fraction balance: dynamic (3 initialization options) or steady state [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 4, 1.0,4.0,0.0,0,2565)
DeclareVariable("heaPum.eva.vol.traceDynamics", "Type of trace substance balance: dynamic (3 initialization options) or steady state [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 4, 1.0,4.0,0.0,0,2565)
DeclareVariable("heaPum.eva.vol.p_start", "Start value of pressure [Pa|bar]", 300000,\
 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("heaPum.eva.vol.T_start", "Start value of temperature [K|degC]",\
 293.15, 1.0,10000.0,300.0,0,2561)
DeclareVariable("heaPum.eva.vol.X_start[1]", "Start value of mass fractions m_i/m [kg/kg]",\
 0.0, 0.0,1.0,0.1,0,2561)
DeclareVariable("heaPum.eva.vol.mSenFac", "Factor for scaling the sensible thermal mass of the volume",\
 1, 1.0,1E+100,0.0,0,2561)
DeclareVariable("heaPum.eva.vol.initialize_p", "= true to set up initial equations for pressure [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("heaPum.eva.vol.prescribedHeatFlowRate", "Set to true if the model has a prescribed heat flow at its heatPort. If the heat flow rate at the heatPort is only based on temperature difference, then set to false [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("heaPum.eva.vol.simplify_mWat_flow", "Set to true to cause port_a.m_flow + port_b.m_flow = 0 even if mWat_flow is non-zero [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("heaPum.eva.vol.m_flow_nominal", "Nominal mass flow rate [kg/s]",\
 2, 0.0,1E+100,0.0,0,2561)
DeclareVariable("heaPum.eva.vol.nPorts", "Number of ports [:#(type=Integer)]", 2,\
 0.0,0.0,0.0,0,2565)
DeclareVariable("heaPum.eva.vol.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 0.0002, 0.0,1E+100,0.0,0,2561)
DeclareVariable("heaPum.eva.vol.allowFlowReversal", "= false to simplify equations, assuming, but not enforcing, no flow reversal. Used only if model has two ports. [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("heaPum.eva.vol.V", "Volume [m3]", 0.0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("heaPum.eva.vol.ports[1].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "sou2.ports[1].m_flow", -1, 5, 19, 1156)
DeclareAlias2("heaPum.eva.vol.ports[1].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "sin2.p", 1, 7, 11, 1028)
DeclareVariable("heaPum.eva.vol.ports[1].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 83680.0, -10000000000.0,10000000000.0,1000000.0,0,2569)
DeclareAlias2("heaPum.eva.vol.ports[2].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "sou2.ports[1].m_flow", 1, 5, 19, 1156)
DeclareAlias2("heaPum.eva.vol.ports[2].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "sin2.p", 1, 7, 11, 1028)
DeclareAlias2("heaPum.eva.vol.ports[2].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "heaPum.port_b2.h_outflow", 1, 5, 69, 1028)
DeclareVariable("heaPum.eva.vol.T", "Temperature of the fluid [K|degC]", 300.0, \
1.0,10000.0,300.0,0,2560)
DeclareVariable("heaPum.eva.vol.U", "Internal energy of the component [J]", 0, \
0.0,0.0,0.0,0,2561)
DeclareAlias2("heaPum.eva.vol.p", "Pressure of the fluid [Pa|bar]", "sin2.p", 1,\
 7, 11, 1024)
DeclareVariable("heaPum.eva.vol.m", "Mass of the component [kg]", 0, 0.0,0.0,0.0,\
0,2561)
DeclareVariable("heaPum.eva.vol.rho_start", "Density, used to compute start and guess values [kg/m3|g/cm3]",\
 995.586, 0.0,1E+100,0.0,0,2561)
DeclareVariable("heaPum.eva.vol.state_default.p", "Absolute pressure of medium [Pa|bar]",\
 300000.0, 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("heaPum.eva.vol.state_default.T", "Temperature of medium [K|degC]",\
 293.15, 1.0,10000.0,300.0,0,2561)
DeclareVariable("heaPum.eva.vol.rho_default", "Density, used to compute fluid mass [kg/m3|g/cm3]",\
 995.586, 0.0,1E+100,0.0,0,2561)
DeclareVariable("heaPum.eva.vol.state_start.p", "Absolute pressure of medium [Pa|bar]",\
 300000, 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("heaPum.eva.vol.state_start.T", "Temperature of medium [K|degC]",\
 293.15, 1.0,10000.0,300.0,0,2561)
DeclareVariable("heaPum.eva.vol.useSteadyStateTwoPort", "Flag, true if the model has two ports only and uses a steady state balance [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareAlias2("heaPum.eva.vol.hOut_internal", "Internal connector for leaving temperature of the component [J/kg]",\
 "heaPum.port_b2.h_outflow", 1, 5, 69, 1024)
DeclareAlias2("heaPum.eva.vol.preTem.port.T", "Port temperature [K|degC]", \
"heaPum.eva.vol.T", 1, 5, 250, 1028)
DeclareAlias2("heaPum.eva.vol.preTem.port.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "heaPum.eva.u", 1, 5, 286, 1156)
DeclareAlias2("heaPum.eva.vol.preTem.T", "[K]", "heaPum.eva.vol.T", 1, 5, 250, 1024)
DeclareAlias2("heaPum.eva.vol.portT.y", "Value of Real output", "heaPum.eva.vol.T", 1,\
 5, 250, 1024)
DeclareAlias2("heaPum.eva.vol.heaFloSen.Q_flow", "Heat flow from port_a to port_b as output signal [W]",\
 "heaPum.eva.u", 1, 5, 286, 1024)
DeclareAlias2("heaPum.eva.vol.heaFloSen.port_a.T", "Port temperature [K|degC]", \
"heaPum.eva.vol.T", 1, 5, 250, 1028)
DeclareAlias2("heaPum.eva.vol.heaFloSen.port_a.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "heaPum.eva.u", 1, 5, 286, 1156)
DeclareAlias2("heaPum.eva.vol.heaFloSen.port_b.T", "Port temperature [K|degC]", \
"heaPum.eva.vol.T", 1, 5, 250, 1028)
DeclareAlias2("heaPum.eva.vol.heaFloSen.port_b.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "heaPum.eva.u", -1, 5, 286, 1156)
DeclareVariable("heaPum.eva.vol.use_C_flow", "Set to true to enable input connector for trace substance [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareAlias2("heaPum.eva.vol.heatPort.T", "Port temperature [K|degC]", \
"heaPum.eva.vol.T", 1, 5, 250, 1028)
DeclareAlias2("heaPum.eva.vol.heatPort.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "heaPum.eva.u", 1, 5, 286, 1156)
DeclareVariable("heaPum.eva.preDro.allowFlowReversal", "= false to simplify equations, assuming, but not enforcing, no flow reversal [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareAlias2("heaPum.eva.preDro.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "sou2.ports[1].m_flow", -1, 5, 19, 1156)
DeclareAlias2("heaPum.eva.preDro.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "sou2.ports[1].p", 1, 5, 20, 1028)
DeclareVariable("heaPum.eva.preDro.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 83680.0, -10000000000.0,10000000000.0,83680.0,0,2569)
DeclareAlias2("heaPum.eva.preDro.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "sou2.ports[1].m_flow", 1, 5, 19, 1156)
DeclareAlias2("heaPum.eva.preDro.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "sin2.p", 1, 7, 11, 1028)
DeclareAlias2("heaPum.eva.preDro.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "sou2.ports[1].h_outflow", 1, 5, 21, 1028)
DeclareVariable("heaPum.eva.preDro.m_flow_nominal", "Nominal mass flow rate [kg/s]",\
 2, 0.0,0.0,0.0,0,2561)
DeclareVariable("heaPum.eva.preDro.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 0.0002, 0.0,1E+100,0.0,0,2561)
DeclareVariable("heaPum.eva.preDro.show_T", "= true, if actual temperature at port is computed [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareAlias2("heaPum.eva.preDro.m_flow", "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction) [kg/s]",\
 "sou2.ports[1].m_flow", -1, 5, 19, 1024)
DeclareVariable("heaPum.eva.preDro.dp", "Pressure difference between port_a and port_b [Pa|Pa]",\
 0, 0.0,0.0,6000.0,0,2560)
DeclareVariable("heaPum.eva.preDro._m_flow_start", "Start value for m_flow, used to avoid a warning if not set in m_flow, and to avoid m_flow.start in parameter window [kg/s]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("heaPum.eva.preDro._dp_start", "Start value for dp, used to avoid a warning if not set in dp, and to avoid dp.start in parameter window [Pa|Pa]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("heaPum.eva.preDro.from_dp", "= true, use m_flow = f(dp) else dp = f(m_flow) [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("heaPum.eva.preDro.dp_nominal", "Pressure drop at nominal mass flow rate [Pa|Pa]",\
 6000, 0.0,0.0,0.0,0,2561)
DeclareVariable("heaPum.eva.preDro.homotopyInitialization", "= true, use homotopy method [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("heaPum.eva.preDro.linearized", "= true, use linear relation between m_flow and dp for any flow rate [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("heaPum.eva.preDro.m_flow_turbulent", "Turbulent flow if |m_flow| >= m_flow_turbulent [kg/s]",\
 0.2, 0.0,1E+100,0.0,0,2561)
DeclareParameter("heaPum.eva.preDro.sta_default.p", "Absolute pressure of medium [Pa|bar]",\
 35, 300000.0, 0.0,100000000.0,100000.0,0,2608)
DeclareParameter("heaPum.eva.preDro.sta_default.T", "Temperature of medium [K|degC]",\
 36, 293.15, 1.0,10000.0,300.0,0,2608)
DeclareVariable("heaPum.eva.preDro.eta_default", "Dynamic viscosity, used to compute transition to turbulent flow regime [Pa.s]",\
 0.001, 0.0,1E+100,0.0,0,2561)
DeclareVariable("heaPum.eva.preDro.m_flow_nominal_pos", "Absolute value of nominal flow rate [kg/s]",\
 2, 0.0,0.0,0.0,0,2561)
DeclareVariable("heaPum.eva.preDro.dp_nominal_pos", "Absolute value of nominal pressure difference [Pa|Pa]",\
 6000, 0.0,0.0,0.0,0,2561)
DeclareVariable("heaPum.eva.preDro.deltaM", "Fraction of nominal mass flow rate where transition to turbulent occurs",\
 0.1, 1E-06,1E+100,0.0,0,2561)
DeclareVariable("heaPum.eva.preDro.k", "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)",\
 0.025819888974716113, 0.0,0.0,0.0,0,2561)
DeclareVariable("heaPum.eva.preDro.computeFlowResistance", "Flag to enable/disable computation of flow resistance [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("heaPum.eva.preDro.coeff", "Precomputed coefficient to avoid division by parameter",\
 0, 0.0,0.0,0.0,0,2561)
DeclareParameter("heaPum.eva.sta_default.p", "Absolute pressure of medium [Pa|bar]",\
 37, 300000.0, 0.0,100000000.0,100000.0,0,2608)
DeclareParameter("heaPum.eva.sta_default.T", "Temperature of medium [K|degC]", 38,\
 293.15, 1.0,10000.0,300.0,0,2608)
DeclareVariable("heaPum.eva.rho_default", "Density, used to compute fluid volume [kg/m3|g/cm3]",\
 995.586, 0.0,1E+100,0.0,0,2561)
DeclareVariable("heaPum.eva.sta_start.p", "Absolute pressure of medium [Pa|bar]",\
 300000, 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("heaPum.eva.sta_start.T", "Temperature of medium [K|degC]", \
293.15, 1.0,10000.0,300.0,0,2561)
DeclareVariable("heaPum.eva.h_outflow_start", "Start value for outflowing enthalpy [J/kg]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("heaPum.eva.Q_flow_nominal", "Heat flow rate at u=1, positive for heating [W]",\
 1, 0.0,0.0,0.0,0,2561)
DeclareVariable("heaPum.eva.u", "Control input [1]", 0.0, 0.0,0.0,0.0,0,2560)
DeclareAlias2("heaPum.eva.Q_flow", "Heat added to the fluid [W]", "heaPum.eva.u", 1,\
 5, 286, 1024)
DeclareParameter("heaPum.eva.preHea.T_ref", "Reference temperature [K|degC]", 39,\
 293.15, 0.0,1E+100,300.0,0,2608)
DeclareVariable("heaPum.eva.preHea.alpha", "Temperature coefficient of heat flow rate [1/K]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("heaPum.eva.preHea.Q_flow", "[W]", "heaPum.eva.u", 1, 5, 286, 1024)
DeclareAlias2("heaPum.eva.preHea.port.T", "Port temperature [K|degC]", \
"heaPum.eva.vol.T", 1, 5, 250, 1028)
DeclareAlias2("heaPum.eva.preHea.port.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "heaPum.eva.u", -1, 5, 286, 1156)
DeclareVariable("heaPum.eva.gai.k", "Gain value multiplied with input signal [1]",\
 1.0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("heaPum.eva.gai.u", "Input signal connector", "heaPum.eva.u", 1, 5,\
 286, 1024)
DeclareAlias2("heaPum.eva.gai.y", "Output signal connector", "heaPum.eva.u", 1, 5,\
 286, 1024)
DeclareVariable("heaPum.QEva_flow_min", "Maximum heat flow rate for cooling (negative) [W]",\
 -60000, -1E+100,0.0,0.0,0,513)
DeclareVariable("heaPum.QCon_flow_max", "Maximum heat flow rate for heating (positive) [W]",\
 30000, 0.0,1E+100,0.0,0,513)
DeclareVariable("heaPum.Q_heating_nominal", "[W]", 100000.0, 0.0,1E+100,0.0,0,513)
DeclareParameter("heaPum.Q_cooling_nominal", "[W]", 40, -1000, -1E+100,0.0,0.0,0,560)
DeclareAlias2("heaPum.TSet", "Condenser leaving water temperature [K]", \
"TConLvg.y", 1, 5, 56, 0)
DeclareParameter("heaPum.modi.threshold", "Comparison with respect to threshold",\
 41, 284.15, 0.0,0.0,0.0,0,560)
DeclareAlias2("heaPum.modi.u", "Connector of Boolean input signal", "TConLvg.y", 1,\
 5, 56, 0)
DeclareAlias2("heaPum.modi.y", "Connector of Boolean output signal [:#(type=Boolean)]",\
 "heaPum.COP_is_for_cooling", 1, 5, 112, 65)
DeclareAlias2("heaPum.realExpression2.y", "Value of Real output", "QEva_flow.u2", 1,\
 5, 60, 0)
DeclareAlias2("heaPum.is_cooling", "[:#(type=Boolean)]", "heaPum.COP_is_for_cooling", 1,\
 5, 112, 65)
DeclareVariable("heaPum.realExpression.y", "Value of Real output", 0.0, 0.0,0.0,\
0.0,0,512)
DeclareAlias2("heaPum.Q_flow_internal.u1", "Connector of Real input signal 1", \
"heaPum.realExpression.y", 1, 5, 292, 1024)
DeclareAlias2("heaPum.Q_flow_internal.u2", "Connector of Real input signal 2", \
"QEva_flow.u2", 1, 5, 60, 1024)
DeclareAlias2("heaPum.Q_flow_internal.y", "Connector of Real output signal", \
"heaPum.eva.u", 1, 5, 286, 1024)
DeclareVariable("heaPum.Q_flow_internal.k1", "Gain of upper input", -1, 0.0,0.0,\
0.0,0,2561)
DeclareParameter("heaPum.Q_flow_internal.k2", "Gain of lower input", 42, 1, \
0.0,0.0,0.0,0,2608)
DeclareAlias2("heaPum.con.outCon.TSet", "Set point temperature of the fluid that leaves port_b [K|degC]",\
 "TConLvg.y", 1, 5, 56, 1024)
DeclareVariable("heaPum.eva.vol.steBal.allowFlowReversal", "= false to simplify equations, assuming, but not enforcing, no flow reversal [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareAlias2("heaPum.eva.vol.steBal.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "sou2.ports[1].m_flow", -1, 5, 19, 1156)
DeclareAlias2("heaPum.eva.vol.steBal.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "sin2.p", 1, 7, 11, 1028)
DeclareVariable("heaPum.eva.vol.steBal.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 83680.0, -10000000000.0,10000000000.0,83680.0,0,2569)
DeclareAlias2("heaPum.eva.vol.steBal.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "sou2.ports[1].m_flow", 1, 5, 19, 1156)
DeclareAlias2("heaPum.eva.vol.steBal.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "sin2.p", 1, 7, 11, 1028)
DeclareAlias2("heaPum.eva.vol.steBal.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "heaPum.port_b2.h_outflow", 1, 5, 69, 1028)
DeclareVariable("heaPum.eva.vol.steBal.m_flow_nominal", "Nominal mass flow rate [kg/s]",\
 2.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("heaPum.eva.vol.steBal.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 0.0002, 0.0,1E+100,0.0,0,2561)
DeclareVariable("heaPum.eva.vol.steBal.show_T", "= true, if actual temperature at port is computed [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareAlias2("heaPum.eva.vol.steBal.m_flow", "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction) [kg/s]",\
 "sou2.ports[1].m_flow", -1, 5, 19, 1024)
DeclareVariable("heaPum.eva.vol.steBal.dp", "Pressure difference between port_a and port_b [Pa|Pa]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("heaPum.eva.vol.steBal._m_flow_start", "Start value for m_flow, used to avoid a warning if not set in m_flow, and to avoid m_flow.start in parameter window [kg/s]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("heaPum.eva.vol.steBal._dp_start", "Start value for dp, used to avoid a warning if not set in dp, and to avoid dp.start in parameter window [Pa|Pa]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("heaPum.eva.vol.steBal.simplify_mWat_flow", "Set to true to cause port_a.m_flow + port_b.m_flow = 0 even if mWat_flow is non-zero [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("heaPum.eva.vol.steBal.prescribedHeatFlowRate", "Set to true if the heat flow rate is not a function of a temperature difference to the fluid temperature [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("heaPum.eva.vol.steBal.use_mWat_flow", "Set to true to enable input connector for moisture mass flow rate [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("heaPum.eva.vol.steBal.use_C_flow", "Set to true to enable input connector for trace substance [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareAlias2("heaPum.eva.vol.steBal.Q_flow", "Sensible plus latent heat flow rate transferred into the medium [W]",\
 "heaPum.eva.u", 1, 5, 286, 1024)
DeclareAlias2("heaPum.eva.vol.steBal.hOut", "Leaving specific enthalpy of the component [J/kg]",\
 "heaPum.port_b2.h_outflow", 1, 5, 69, 1024)
DeclareVariable("heaPum.eva.vol.steBal.use_m_flowInv", "Flag, true if m_flowInv is used in the model [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("heaPum.eva.vol.steBal.m_flowInv", "Regularization of 1/m_flow of port_a [s/kg]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("heaPum.eva.vol.steBal.deltaReg", "Smoothing region for inverseXRegularized",\
 2.0000000000000002E-07, 0.0,0.0,0.0,0,2561)
DeclareVariable("heaPum.eva.vol.steBal.deltaInvReg", "Inverse value of delta for inverseXRegularized",\
 5000000.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("heaPum.eva.vol.steBal.aReg", "Polynomial coefficient for inverseXRegularized",\
 -75000000.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("heaPum.eva.vol.steBal.bReg", "Polynomial coefficient for inverseXRegularized",\
 2.975E+15, 0.0,0.0,0.0,0,2561)
DeclareVariable("heaPum.eva.vol.steBal.cReg", "Polynomial coefficient for inverseXRegularized",\
 -4.5125E+22, 0.0,0.0,0.0,0,2561)
DeclareVariable("heaPum.eva.vol.steBal.dReg", "Polynomial coefficient for inverseXRegularized",\
 3.3375E+29, 0.0,0.0,0.0,0,2561)
DeclareVariable("heaPum.eva.vol.steBal.eReg", "Polynomial coefficient for inverseXRegularized",\
 -1.1875E+36, 0.0,0.0,0.0,0,2561)
DeclareVariable("heaPum.eva.vol.steBal.fReg", "Polynomial coefficient for inverseXRegularized",\
 1.625E+42, 0.0,0.0,0.0,0,2561)
DeclareVariable("heaPum.eva.vol.steBal.state_default.p", "Absolute pressure of medium [Pa|bar]",\
 300000.0, 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("heaPum.eva.vol.steBal.state_default.T", "Temperature of medium [K|degC]",\
 293.15, 1.0,10000.0,300.0,0,2561)
DeclareVariable("heaPum.eva.vol.steBal.cp_default", "Specific heat capacity, used to verify energy conservation [J/(kg.K)]",\
 4184, 0.0,0.0,0.0,0,2561)
DeclareVariable("heaPum.eva.vol.steBal.dTMax", "Maximum temperature difference across the StaticTwoPortConservationEquation [K,]",\
 200, 1.0,1E+100,0.0,0,2561)
DeclareVariable("heaPum.eva.vol.steBal.mWat_flow_internal", "Needed to connect to conditional connector [kg/s]",\
 0, 0.0,0.0,0.0,0,2561)
EndNonAlias(0)

#define DymolaHaveUpdateInitVars 1
#include <dsblock5.c>

DYMOLA_STATIC void UpdateInitVars(double*time, double* X_, double* XD_, double* U_, double* DP_, int IP_[], Dymola_bool LP_[], double* F_, double* Y_, double* W_, double QZ_[], double duser_[], int iuser_[], void*cuser_[],struct DYNInstanceData*did_,int initialCall) {
if (initialCall) DYNX(did_->xInitial_var, 0)=DYNX(W_,110);
else if (DYNHReject) DYNX(W_,110)=did_->xInitial_var2[0]; else did_->xInitial_var2[0]=
  DYNX(W_,110);
if (initialCall) DYNX(did_->xInitial_var, 1)=DYNX(W_,111);
else if (DYNHReject) DYNX(W_,111)=did_->xInitial_var2[1]; else did_->xInitial_var2[1]=
  DYNX(W_,111);
}
StartDataBlock
StartEqBlock
DoRemember_(DYNX(W_,87), 0.0, 0);
DoRemember_(DYNX(W_,110), 2+DYNX(DP_,23), 1);
DoRemember_(DYNX(W_,111), DYNX(DP_,24)-2, 2);
DYNSetRememberAcceptedBase(0);
EndEqBlock
EndDataBlock

BreakSectionFunctionStart(0);
BreakSectionFunctionCallNew(1);
BreakSectionFunctionEnd()
