#define DYNEventSpecial
/* DSblock model generated by Dymola from Modelica model AixLib.Controls.SetPoints.Examples.Table
 Dymola Version 2019 (64-bit), 2018-04-11 translated this at Wed Jul  3 10:21:21 2019

   */

#include <matrixop.h>
/* Declaration of C-structs */
struct DymStruc0;
struct DymStruc0 {
  int  id_0member;
};
DYMOLA_STATIC struct DymStruc0 DymStruc0_construct(int   id_02) {
  struct DymStruc0 dummy_0;
  dummy_0.id_0member = id_02;
  return dummy_0;
}
/* Prototypes for functions used in model */
DYMOLA_STATIC double   Modelica_Blocks_Tables_CombiTable1D_getTableValue_M(
  struct DymStruc0 tableID0_0, int  icol0_0, double  u0_0, double  
  tableAvailable0_0);
DYMOLA_STATIC struct DymStruc0  Modelica_Blocks_Types_ExternalCombiTable1D_M(
  const char*  tableName0_0, const char*  fileName0_0, RealArray   table0_0, 
  IntegerArray   columns0_0, int  smoothness0_0, int id_, int alwaysMakeNew_);
DYMOLA_STATIC void Modelica_Blocks_Types_ExternalCombiTable1D_destructor_M(
  void* externalCombiTable1D0_0);
/* Codes used in model */

/* Flattened Modelica model:

function Modelica.Blocks.Tables.CombiTable1D.getTableValue
input Modelica.Blocks.Types.ExternalCombiTable1D tableID;
input Integer icol;
discrete input Real u;
discrete input Real tableAvailable "Dummy input to ensure correct sorting of function calls";
discrete output Real y;

external "C" y = ModelicaStandardTables_CombiTable1D_getValue(tableID, icol, u);
annotation(derivative(noDerivative=tableAvailable)=Modelica.Blocks.Tables.CombiTable1D.getDerTableValue, Library={"ModelicaMatIO", "ModelicaStandardTables", "zlib"}, LibraryDirectory="modelica://Modelica/Resources/Library");
end Modelica.Blocks.Tables.CombiTable1D.getTableValue;

  */
extern double (ModelicaStandardTables_CombiTable1D_getValue)(void*, int , double );
DYMOLA_STATIC double   Modelica_Blocks_Tables_CombiTable1D_getTableValue_M(
  struct DymStruc0 tableID0_0, int  icol0_0, double  u0_0, double  
  tableAvailable0_0) {
  PushContext("Modelica.Blocks.Tables.CombiTable1D.getTableValue")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    y0_0=0;
    /* Start of real code */
    {
      y0_0 = (ModelicaStandardTables_CombiTable1D_getValue)(externalTable_[
        tableID0_0.id_0member].obj_, icol0_0, u0_0);
      }
    /* Output section */
    PopContext()
    return y0_0;
  }}

/* Flattened Modelica model:

function constructor
input String tableName "Table name";
input String fileName "File name";
discrete input Real table[:, :];
input Integer columns[:];
input Modelica.Blocks.Types.Smoothness smoothness;
output Modelica.Blocks.Types.ExternalCombiTable1D externalCombiTable1D;

external "C" externalCombiTable1D = ModelicaStandardTables_CombiTable1D_init(tableName, fileName, table, size(table, 1), size(table, 2), columns, size(columns, 1), smoothness);
annotation(Library={"ModelicaStandardTables"}, LibraryDirectory="modelica://Modelica/Resources/Library");
end constructor;

  */
extern void* (ModelicaStandardTables_CombiTable1D_init)(const char* , 
  const char* , double  const *, size_t, size_t, int  const *, size_t, int );
DYMOLA_STATIC struct DymStruc0  Modelica_Blocks_Types_ExternalCombiTable1D_M(
  const char*  tableName0_0, const char*  fileName0_0, RealArray   table0_0, 
  IntegerArray   columns0_0, int  smoothness0_0, int id_, int alwaysMakeNew_) {
  PushContext("Modelica.Blocks.Types.ExternalCombiTable1D")
  {
    /* Declare outputs and temporaries */
    struct DymStruc0  externalCombiTable1D0_0;
    externalCombiTable1D0_0.id_0member=0;
    /* Start of real code */
    {
      externalCombiTable1D0_0.id_0member=id_;
      if (externalTable_[id_].destructor_ && externalTable_[id_].obj_ && alwaysMakeNew_) {
      void*x_=externalTable_[id_].obj_;
      externalTable_[id_].obj_=0;
      (*(externalTable_[id_].destructor_))(x_);
      } else if (!externalTable_[id_].destructor_) {externalTable_[id_].obj_=0;}
      #if (defined(_OPENMP) && !defined(DISABLE_DYMOLA_OPENMP))
      if (!(externalTable_[id_].haveLock_)) {omp_init_lock(&(externalTable_[id_].lockExternal_));externalTable_[id_].haveLock_=1;}
      #endif
      externalTable_[id_].destructor_=Modelica_Blocks_Types_ExternalCombiTable1D_destructor_M;

        if (!externalTable_[id_].obj_) externalTable_[id_].obj_ = (
        ModelicaStandardTables_CombiTable1D_init)(tableName0_0, fileName0_0, 
        table0_0.data, table0_0.dims[1-1], table0_0.dims[2-1], columns0_0.data, 
        columns0_0.dims[1-1], smoothness0_0);
      }
    /* Output section */
    PopContext()
    return externalCombiTable1D0_0;
  }}

/* Flattened Modelica model:

function destructor
input Modelica.Blocks.Types.ExternalCombiTable1D externalCombiTable1D;

external "C" ModelicaStandardTables_CombiTable1D_close(externalCombiTable1D);
annotation(Library={"ModelicaStandardTables"}, LibraryDirectory="modelica://Modelica/Resources/Library");
end destructor;

  */
extern void (ModelicaStandardTables_CombiTable1D_close)(void*);
DYMOLA_STATIC void Modelica_Blocks_Types_ExternalCombiTable1D_destructor_M(
  void* externalCombiTable1D0_0) {
  PushContext("Modelica.Blocks.Types.ExternalCombiTable1D.destructor")
  {
    /* Declare outputs and temporaries */
    /* Start of real code */
    {
      (ModelicaStandardTables_CombiTable1D_close)(externalCombiTable1D0_0);
      }
    /* Output section */
    PopContext()
    return ;
  }}
/* DSblock C-code: */

#define NX_    0
#define NX2_   0
#define NU_    0
#define NY_    0
#define NW_    59
#define NP_    24
#define NPS_   0
#define ND_   0
#define NXP_   0
#define NInitial_   0
#define MAXAuxStr_   4
#define MAXAuxStrLen_   500
#define NHash1_ -1343990668
#define NHash2_ 98632165
#define NHash3_ 0
#define NI_    0
#define NRelF_ 0
#define NRel_  0
#define NTim_  2
#define NSamp_ 0
#define NCons_ 0
#define NA_    6
#define SizePre_ 0
#define SizeEq_ 0
#define SizeDelay_ 0
#define QNLmax_ 0
#define MAXAux 0
#define NrDymolaTimers_ 0
#define NWhen_ 0
#define NCheckIf_ 0
#define NGlobalHelp_ 0
#define NGlobalHelpI_ 0
#ifndef NExternalObject_
#define NExternalObject_ 2
#endif
#include <moutil.c>
DYMOLA_STATIC unsigned int FMIClockValueReferences_[1]={0};
DYMOLA_STATIC unsigned int FMIClockFirstValueReferences_[1]={0};
PreNonAliasDef(0)
PreNonAliasDef(1)
PreNonAliasDef(2)
PreNonAliasDef(3)
PreNonAliasDef(4)
PreNonAliasDef(5)
#if !defined(DYM2CCUR)
 DYMOLA_STATIC const char*modelName="AixLib.Controls.SetPoints.Examples.Table";
#endif
DYMOLA_STATIC const char*usedLibraries[]={0};
DYMOLA_STATIC const char*dllLibraryPath[]={0};
DYMOLA_STATIC const char*default_dymosim_license_filename=
 "c:/programdata/dassaultsystemes/dymola/dymola.lic";
#include <dsblock1.c>

/* Define variable names. */

#define Sections_

TranslatedEquations

InitialSection
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,2) = true;
DYNX(W_,3) = 6;
DYNX(W_,16) = 1;
DYNX(W_,35) = false;
DYNX(W_,36) = 4;
DYNX(W_,45) = 1;
DYNX(W_,4) = 0.0;
DYNX(W_,6) = 0.0;
DYNX(W_,8) = 0.0;
DYNX(W_,10) = 0.0;
DYNX(W_,12) = 0.0;
DYNX(W_,14) = 0.0;
#endif
DYNSetAuxString(did_, "NoName", 0);
DYNSetAuxString(did_, "NoName", 1);
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,30) = 2;
DYNX(W_,37) = 0.0;
DYNX(W_,39) = 0.0;
DYNX(W_,41) = 0.0;
DYNX(W_,43) = 0.0;
#endif
DYNSetAuxString(did_, "NoName", 2);
DYNSetAuxString(did_, "NoName", 3);
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,55) = 2;
DYNX(W_,17) = false;
DYNX(W_,31) = 1;
DYNX(W_,46) = false;
DYNX(W_,56) = 1;
#endif
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
BoundParameterSection
DYNX(W_,5) = DYNX(DP_,8);
DYNX(W_,7) = DYNX(DP_,8);
DYNX(W_,9) = DYNX(DP_,8);
DYNX(W_,11) = DYNX(DP_,8);
DYNX(W_,13) = DYNX(DP_,8);
DYNX(W_,15) = DYNX(DP_,8);
DYNX(W_,18) = DYNX(DP_,0)+DYNX(W_,4)-1;
DYNX(W_,19) = DYNX(DP_,1)+DYNX(W_,5);
DYNX(W_,20) = DYNX(DP_,0)+DYNX(W_,6);
DYNX(W_,21) = DYNX(DP_,1)+DYNX(W_,7);
DYNX(W_,22) = DYNX(DP_,2)+DYNX(W_,8);
DYNX(W_,23) = DYNX(DP_,3)+DYNX(W_,9);
DYNX(W_,24) = DYNX(DP_,4)+DYNX(W_,10);
DYNX(W_,25) = DYNX(DP_,5)+DYNX(W_,11);
DYNX(W_,26) = DYNX(DP_,6)+DYNX(W_,12);
DYNX(W_,27) = DYNX(DP_,7)+DYNX(W_,13);
DYNX(W_,28) = 1.0+DYNX(DP_,6)+DYNX(W_,14);
DYNX(W_,29) = DYNX(DP_,7)+DYNX(W_,15);
DYNX(W_,38) = DYNX(DP_,22);
DYNX(W_,40) = DYNX(DP_,22);
DYNX(W_,42) = DYNX(DP_,22);
DYNX(W_,44) = DYNX(DP_,22);
DYNX(W_,47) = DYNX(DP_,14)+DYNX(W_,37);
DYNX(W_,48) = DYNX(DP_,15)+DYNX(W_,38);
DYNX(W_,49) = DYNX(DP_,16)+DYNX(W_,39);
DYNX(W_,50) = DYNX(DP_,17)+DYNX(W_,40);
DYNX(W_,51) = DYNX(DP_,18)+DYNX(W_,41);
DYNX(W_,52) = DYNX(DP_,19)+DYNX(W_,42);
DYNX(W_,53) = DYNX(DP_,20)+DYNX(W_,43);
DYNX(W_,54) = DYNX(DP_,21)+DYNX(W_,44);
InitialBoundSection
{
  struct DymStruc0 dummy_DymStruc0;
  dummy_DymStruc0 = (PushModelContext(1,"Modelica.Blocks.Types.ExternalCombiTable1D(\"NoName\", \"NoName\", tabConExt.tab.table, tabConExt.tab.columns, Modelica.Blocks.Types.Smoothness.LinearSegments, 0, 1)")
    Modelica_Blocks_Types_ExternalCombiTable1D_M("NoName", "NoName", 
    RealTemporaryDense( &DYNX(W_,18), 2, 6, 2), IntegerTemporaryDense( 
    &DYNX(W_,30), 1, 1), 1, 0, 1));
  DYNX(W_,32) = dummy_DymStruc0.id_0member;
PopAllMarks();
}
{
  struct DymStruc0 dummy_DymStruc0;
  dummy_DymStruc0 = (PushModelContext(1,"Modelica.Blocks.Types.ExternalCombiTable1D(\"NoName\", \"NoName\", tabLinExt.tab.table, tabLinExt.tab.columns, Modelica.Blocks.Types.Smoothness.LinearSegments, 1, 1)")
    Modelica_Blocks_Types_ExternalCombiTable1D_M("NoName", "NoName", 
    RealTemporaryDense( &DYNX(W_,47), 2, 4, 2), IntegerTemporaryDense( 
    &DYNX(W_,55), 1, 1), 1, 1, 1));
  DYNX(W_,57) = dummy_DymStruc0.id_0member;
PopAllMarks();
}
BoundParameterSection
InitialSection
InitialSection
InitialStartSection
InitialSection
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
DefaultSection
InitializeData(0)
InitialSection
InitialSection2
DYNX(W_,5) = DYNX(DP_,8);
DYNX(W_,7) = DYNX(DP_,8);
DYNX(W_,9) = DYNX(DP_,8);
DYNX(W_,11) = DYNX(DP_,8);
DYNX(W_,13) = DYNX(DP_,8);
DYNX(W_,15) = DYNX(DP_,8);
DYNX(W_,18) = DYNX(DP_,0)+DYNX(W_,4)-1;
DYNX(W_,19) = DYNX(DP_,1)+DYNX(W_,5);
DYNX(W_,20) = DYNX(DP_,0)+DYNX(W_,6);
DYNX(W_,21) = DYNX(DP_,1)+DYNX(W_,7);
DYNX(W_,22) = DYNX(DP_,2)+DYNX(W_,8);
DYNX(W_,23) = DYNX(DP_,3)+DYNX(W_,9);
DYNX(W_,24) = DYNX(DP_,4)+DYNX(W_,10);
DYNX(W_,25) = DYNX(DP_,5)+DYNX(W_,11);
DYNX(W_,26) = DYNX(DP_,6)+DYNX(W_,12);
DYNX(W_,27) = DYNX(DP_,7)+DYNX(W_,13);
DYNX(W_,28) = 1.0+DYNX(DP_,6)+DYNX(W_,14);
DYNX(W_,29) = DYNX(DP_,7)+DYNX(W_,15);
DYNX(W_,38) = DYNX(DP_,22);
DYNX(W_,40) = DYNX(DP_,22);
DYNX(W_,42) = DYNX(DP_,22);
DYNX(W_,44) = DYNX(DP_,22);
DYNX(W_,47) = DYNX(DP_,14)+DYNX(W_,37);
DYNX(W_,48) = DYNX(DP_,15)+DYNX(W_,38);
DYNX(W_,49) = DYNX(DP_,16)+DYNX(W_,39);
DYNX(W_,50) = DYNX(DP_,17)+DYNX(W_,40);
DYNX(W_,51) = DYNX(DP_,18)+DYNX(W_,41);
DYNX(W_,52) = DYNX(DP_,19)+DYNX(W_,42);
DYNX(W_,53) = DYNX(DP_,20)+DYNX(W_,43);
DYNX(W_,54) = DYNX(DP_,21)+DYNX(W_,44);
DYNX(W_,33) = 0.0;
  {
    DYNX(W_,33) = 1.0;
  }
DYNX(W_,58) = 0.0;
  {
    DYNX(W_,58) = 1.0;
  }
InitialBoundSection
{
  struct DymStruc0 dummy_DymStruc0;
  dummy_DymStruc0 = (PushModelContext(1,"Modelica.Blocks.Types.ExternalCombiTable1D(\"NoName\", \"NoName\", tabConExt.tab.table, tabConExt.tab.columns, Modelica.Blocks.Types.Smoothness.LinearSegments, 0, 1)")
    Modelica_Blocks_Types_ExternalCombiTable1D_M("NoName", "NoName", 
    RealTemporaryDense( &DYNX(W_,18), 2, 6, 2), IntegerTemporaryDense( 
    &DYNX(W_,30), 1, 1), 1, 0, 1));
  DYNX(W_,32) = dummy_DymStruc0.id_0member;
PopAllMarks();
}
{
  struct DymStruc0 dummy_DymStruc0;
  dummy_DymStruc0 = (PushModelContext(1,"Modelica.Blocks.Types.ExternalCombiTable1D(\"NoName\", \"NoName\", tabLinExt.tab.table, tabLinExt.tab.columns, Modelica.Blocks.Types.Smoothness.LinearSegments, 1, 1)")
    Modelica_Blocks_Types_ExternalCombiTable1D_M("NoName", "NoName", 
    RealTemporaryDense( &DYNX(W_,47), 2, 4, 2), IntegerTemporaryDense( 
    &DYNX(W_,55), 1, 1), 1, 1, 1));
  DYNX(W_,57) = dummy_DymStruc0.id_0member;
PopAllMarks();
}
InitialSection
InitialSectionB
Init_=false;InitializeData(2);Init_=true;
EndInitialSection

OutputSection

DynamicsSection

AcceptedSection1

AcceptedSection2
DYNX(W_,0) = DYNX(DP_,12)+(IF LessTime(DYNX(DP_,13), 0) THEN 0 ELSE IF LessTime(
  DYNX(DP_,13)+DYNX(DP_,11), 1) THEN divmacro((DYNTime-DYNX(DP_,13))*
  DYNX(DP_,10),"(time-TRoo.startTime)*TRoo.height",DYNX(DP_,11),"TRoo.duration")
   ELSE DYNX(DP_,10));
DYNX(W_,1) = (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1D.getTableValue(\ntabConExt.tab.tableID, \n1, \ntabConExt.u, \ntabConExt.tab.tableOnFileRead)")
  Modelica_Blocks_Tables_CombiTable1D_getTableValue_M(DymStruc0_construct(
  (Integer)(DYNX(W_,32))), 1, DYNX(W_,0), DYNX(W_,33)));
PopModelContext();
DYNX(W_,34) = (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1D.getTableValue(\ntabLinExt.tab.tableID, \n1, \ntabConExt.u, \ntabLinExt.tab.tableOnFileRead)")
  Modelica_Blocks_Tables_CombiTable1D_getTableValue_M(DymStruc0_construct(
  (Integer)(DYNX(W_,57))), 1, DYNX(W_,0), DYNX(W_,58)));
PopModelContext();

DefaultSection
InitializeData(1)
EndTranslatedEquations

#include <dsblock6.c>

PreNonAliasNew(0)
StartNonAlias(0)
DeclareVariable("tabConExt.u", "Connector of Real input signal", 0.0, 0.0,0.0,\
0.0,0,512)
DeclareVariable("tabConExt.y", "Connector of Real output signal", 0.0, 0.0,0.0,\
0.0,0,512)
DeclareParameter("tabConExt.table[1, 1]", "Table matrix ( e.g., table=[u1, y1; u2, y2; u3, y3])",\
 0, 20, 0.0,0.0,0.0,0,560)
DeclareParameter("tabConExt.table[1, 2]", "Table matrix ( e.g., table=[u1, y1; u2, y2; u3, y3])",\
 1, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("tabConExt.table[2, 1]", "Table matrix ( e.g., table=[u1, y1; u2, y2; u3, y3])",\
 2, 22.0, 0.0,0.0,0.0,0,560)
DeclareParameter("tabConExt.table[2, 2]", "Table matrix ( e.g., table=[u1, y1; u2, y2; u3, y3])",\
 3, 0.5, 0.0,0.0,0.0,0,560)
DeclareParameter("tabConExt.table[3, 1]", "Table matrix ( e.g., table=[u1, y1; u2, y2; u3, y3])",\
 4, 25.0, 0.0,0.0,0.0,0,560)
DeclareParameter("tabConExt.table[3, 2]", "Table matrix ( e.g., table=[u1, y1; u2, y2; u3, y3])",\
 5, 0.5, 0.0,0.0,0.0,0,560)
DeclareParameter("tabConExt.table[4, 1]", "Table matrix ( e.g., table=[u1, y1; u2, y2; u3, y3])",\
 6, 26, 0.0,0.0,0.0,0,560)
DeclareParameter("tabConExt.table[4, 2]", "Table matrix ( e.g., table=[u1, y1; u2, y2; u3, y3])",\
 7, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("tabConExt.offset", "Offset of output signal", 8, 0, 0.0,0.0,\
0.0,0,560)
DeclareVariable("tabConExt.constantExtrapolation", "If true, then y=y1 for u<u1, and y=yMax for u>uMax [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("tabConExt.nRow", "Number of rows [:#(type=Integer)]", 6, \
0.0,0.0,0.0,0,2565)
DeclareVariable("tabConExt.offsetVector[1, 1]", "Vector to take offset of output signal into account",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("tabConExt.offsetVector[1, 2]", "Vector to take offset of output signal into account",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("tabConExt.offsetVector[2, 1]", "Vector to take offset of output signal into account",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("tabConExt.offsetVector[2, 2]", "Vector to take offset of output signal into account",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("tabConExt.offsetVector[3, 1]", "Vector to take offset of output signal into account",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("tabConExt.offsetVector[3, 2]", "Vector to take offset of output signal into account",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("tabConExt.offsetVector[4, 1]", "Vector to take offset of output signal into account",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("tabConExt.offsetVector[4, 2]", "Vector to take offset of output signal into account",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("tabConExt.offsetVector[5, 1]", "Vector to take offset of output signal into account",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("tabConExt.offsetVector[5, 2]", "Vector to take offset of output signal into account",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("tabConExt.offsetVector[6, 1]", "Vector to take offset of output signal into account",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("tabConExt.offsetVector[6, 2]", "Vector to take offset of output signal into account",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("tabConExt.tab.n", "Number of inputs (= number of outputs) [:#(type=Integer)]",\
 1, 0.0,0.0,0.0,0,2565)
DeclareAlias2("tabConExt.tab.u[1]", "Connector of Real input signals", \
"tabConExt.u", 1, 5, 0, 1024)
DeclareAlias2("tabConExt.tab.y[1]", "Connector of Real output signals", \
"tabConExt.y", 1, 5, 1, 1024)
DeclareVariable("tabConExt.tab.tableOnFile", "= true, if table is defined on file or in function usertab [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("tabConExt.tab.table[1, 1]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("tabConExt.tab.table[1, 2]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("tabConExt.tab.table[2, 1]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("tabConExt.tab.table[2, 2]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("tabConExt.tab.table[3, 1]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("tabConExt.tab.table[3, 2]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("tabConExt.tab.table[4, 1]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("tabConExt.tab.table[4, 2]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("tabConExt.tab.table[5, 1]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("tabConExt.tab.table[5, 2]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("tabConExt.tab.table[6, 1]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("tabConExt.tab.table[6, 2]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareParameter("tabConExt.tab.verboseRead", "= true, if info message that file is loading is to be printed [:#(type=Boolean)]",\
 9, true, 0.0,0.0,0.0,0,2610)
DeclareVariable("tabConExt.tab.columns[1]", "Columns of table to be interpolated [:#(type=Integer)]",\
 2, 0.0,0.0,0.0,0,2565)
DeclareVariable("tabConExt.tab.smoothness", "Smoothness of table interpolation [:#(type=Modelica.Blocks.Types.Smoothness)]",\
 1, 1.0,5.0,0.0,0,2565)
DeclareVariable("tabConExt.tab.tableID.id", "[:#(type=Integer)]", 0, 0.0,0.0,0.0,\
0,2565)
DeclareVariable("tabConExt.tab.tableOnFileRead", "= 1, if table was successfully read from file",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareParameter("TRoo.height", "Height of ramps", 10, 15, 0.0,0.0,0.0,0,560)
DeclareParameter("TRoo.duration", "Duration of ramp (= 0.0 gives a Step) [s]", 11,\
 1, 0.0,1E+100,0.0,0,560)
DeclareParameter("TRoo.offset", "Offset of output signal", 12, 15, 0.0,0.0,0.0,0,560)
DeclareParameter("TRoo.startTime", "Output = offset for time < startTime [s]", 13,\
 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("TRoo.y", "Connector of Real output signal", "tabConExt.u", 1, 5, 0,\
 0)
DeclareAlias2("tabLinExt.u", "Connector of Real input signal", "tabConExt.u", 1,\
 5, 0, 0)
DeclareVariable("tabLinExt.y", "Connector of Real output signal", 0.0, 0.0,0.0,\
0.0,0,512)
DeclareParameter("tabLinExt.table[1, 1]", "Table matrix ( e.g., table=[u1, y1; u2, y2; u3, y3])",\
 14, 20, 0.0,0.0,0.0,0,560)
DeclareParameter("tabLinExt.table[1, 2]", "Table matrix ( e.g., table=[u1, y1; u2, y2; u3, y3])",\
 15, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("tabLinExt.table[2, 1]", "Table matrix ( e.g., table=[u1, y1; u2, y2; u3, y3])",\
 16, 22.0, 0.0,0.0,0.0,0,560)
DeclareParameter("tabLinExt.table[2, 2]", "Table matrix ( e.g., table=[u1, y1; u2, y2; u3, y3])",\
 17, 0.5, 0.0,0.0,0.0,0,560)
DeclareParameter("tabLinExt.table[3, 1]", "Table matrix ( e.g., table=[u1, y1; u2, y2; u3, y3])",\
 18, 25.0, 0.0,0.0,0.0,0,560)
DeclareParameter("tabLinExt.table[3, 2]", "Table matrix ( e.g., table=[u1, y1; u2, y2; u3, y3])",\
 19, 0.5, 0.0,0.0,0.0,0,560)
DeclareParameter("tabLinExt.table[4, 1]", "Table matrix ( e.g., table=[u1, y1; u2, y2; u3, y3])",\
 20, 26, 0.0,0.0,0.0,0,560)
DeclareParameter("tabLinExt.table[4, 2]", "Table matrix ( e.g., table=[u1, y1; u2, y2; u3, y3])",\
 21, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("tabLinExt.offset", "Offset of output signal", 22, 0, 0.0,0.0,\
0.0,0,560)
DeclareVariable("tabLinExt.constantExtrapolation", "If true, then y=y1 for u<u1, and y=yMax for u>uMax [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("tabLinExt.nRow", "Number of rows [:#(type=Integer)]", 4, \
0.0,0.0,0.0,0,2565)
DeclareVariable("tabLinExt.offsetVector[1, 1]", "Vector to take offset of output signal into account",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("tabLinExt.offsetVector[1, 2]", "Vector to take offset of output signal into account",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("tabLinExt.offsetVector[2, 1]", "Vector to take offset of output signal into account",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("tabLinExt.offsetVector[2, 2]", "Vector to take offset of output signal into account",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("tabLinExt.offsetVector[3, 1]", "Vector to take offset of output signal into account",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("tabLinExt.offsetVector[3, 2]", "Vector to take offset of output signal into account",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("tabLinExt.offsetVector[4, 1]", "Vector to take offset of output signal into account",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("tabLinExt.offsetVector[4, 2]", "Vector to take offset of output signal into account",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("tabLinExt.tab.n", "Number of inputs (= number of outputs) [:#(type=Integer)]",\
 1, 0.0,0.0,0.0,0,2565)
DeclareAlias2("tabLinExt.tab.u[1]", "Connector of Real input signals", \
"tabConExt.u", 1, 5, 0, 1024)
DeclareAlias2("tabLinExt.tab.y[1]", "Connector of Real output signals", \
"tabLinExt.y", 1, 5, 34, 1024)
DeclareVariable("tabLinExt.tab.tableOnFile", "= true, if table is defined on file or in function usertab [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("tabLinExt.tab.table[1, 1]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("tabLinExt.tab.table[1, 2]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("tabLinExt.tab.table[2, 1]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("tabLinExt.tab.table[2, 2]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("tabLinExt.tab.table[3, 1]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("tabLinExt.tab.table[3, 2]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("tabLinExt.tab.table[4, 1]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("tabLinExt.tab.table[4, 2]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareParameter("tabLinExt.tab.verboseRead", "= true, if info message that file is loading is to be printed [:#(type=Boolean)]",\
 23, true, 0.0,0.0,0.0,0,2610)
DeclareVariable("tabLinExt.tab.columns[1]", "Columns of table to be interpolated [:#(type=Integer)]",\
 2, 0.0,0.0,0.0,0,2565)
DeclareVariable("tabLinExt.tab.smoothness", "Smoothness of table interpolation [:#(type=Modelica.Blocks.Types.Smoothness)]",\
 1, 1.0,5.0,0.0,0,2565)
DeclareVariable("tabLinExt.tab.tableID.id", "[:#(type=Integer)]", 0, 0.0,0.0,0.0,\
0,2565)
DeclareVariable("tabLinExt.tab.tableOnFileRead", "= 1, if table was successfully read from file",\
 0.0, 0.0,0.0,0.0,0,2561)
EndNonAlias(0)

#define DymolaHaveUpdateInitVars 1
#include <dsblock5.c>

DYMOLA_STATIC void UpdateInitVars(double*time, double* X_, double* XD_, double* U_, double* DP_, int IP_[], Dymola_bool LP_[], double* F_, double* Y_, double* W_, double QZ_[], double duser_[], int iuser_[], void*cuser_[],struct DYNInstanceData*did_,int initialCall) {
}
StartDataBlock
EndDataBlock
